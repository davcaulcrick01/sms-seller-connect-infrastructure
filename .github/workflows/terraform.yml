name: 'SMS Seller Connect - Terraform CI/CD Pipeline'

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      action:
        description: 'Choose action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
          - format
          - redeploy
          - verify-secrets
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  # Terraform Configuration
  TF_VERSION: '1.5.7'
  TF_WORKING_DIR: './modules/ec2'
  
  # AWS Configuration
  AWS_REGION: 'us-east-1'
  AWS_ACCOUNT_ID: '522814698925'
  
  # Backend Configuration
  STATE_BUCKET: 'greyzone-terraform-state'
  LOCK_TABLE: 'terraform-locks'
  STATE_KEY: 'sms-seller-connect/ec2/terraform.tfstate'
  
  # Application Configuration
  PROJECT_NAME: 'sms-seller-connect'
  ECR_REPOSITORY: '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend'
  DOMAIN_NAME: 'typerelations.com'
  SMS_FRONTEND_DOMAIN: 'sms.typerelations.com'
  SMS_API_DOMAIN: 'api.sms.typerelations.com'
  
  # Environment Selection
  ENVIRONMENT: ${{ github.event.inputs.environment || 'prod' }}

jobs:
  format:
    name: 'ðŸŽ¨ Auto-Format Terraform'
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' || 
      github.event_name == 'pull_request' || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'format')
    
    permissions:
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Auto-Format Terraform Files
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸŽ¨ Auto-formatting Terraform files..."
        
        # Format all terraform files
        terraform fmt -recursive
        
        # Check if any files were changed
        if [[ -n $(git status --porcelain) ]]; then
          echo "âœ… Terraform files have been auto-formatted"
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add and commit changes
          git add .
          git commit -m "ðŸŽ¨ Auto-format Terraform files [skip ci]"
          
          # Push changes
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git push origin HEAD:${{ github.head_ref }}
          else
            git push
          fi
          
          echo "ðŸ“¤ Formatted files committed and pushed"
        else
          echo "â„¹ï¸ All Terraform files are already properly formatted"
        fi

  validate:
    name: 'ðŸ” Validate Terraform'
    runs-on: ubuntu-latest
    needs: [format]
    if: always()
    
    outputs:
      terraform-valid: ${{ steps.validate.outputs.terraform-valid }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸŽ¨ Verifying Terraform formatting..."
        terraform fmt -check -recursive
        echo "âœ… All Terraform files are properly formatted"

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Initializing Terraform..."
        terraform init -backend=false

    - name: Terraform Validate
      id: validate
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "âœ… Validating Terraform configuration..."
        terraform validate
        echo "terraform-valid=true" >> $GITHUB_OUTPUT

    - name: Security Scan with tfsec
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”’ Running security scan with tfsec..."
        
        # Install tfsec
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
        
        # Run tfsec with custom configuration
        ./tfsec . --format json --out tfsec-results.json || true
        
        # Display results
        if [ -f tfsec-results.json ]; then
          echo "ðŸ“Š Security scan results:"
          cat tfsec-results.json | jq '.results[] | select(.severity == "HIGH" or .severity == "CRITICAL") | {rule_id: .rule_id, severity: .severity, description: .description}' || echo "No high/critical issues found"
        fi

  plan:
    name: 'ðŸ“‹ Plan Infrastructure'
    runs-on: ubuntu-latest
    needs: [format, validate]
    if: needs.validate.outputs.terraform-valid == 'true'
    
    outputs:
      plan-status: ${{ steps.plan.outputs.status }}
      has-changes: ${{ steps.plan.outputs.has-changes }}
      infrastructure-exists: ${{ steps.check-infrastructure.outputs.exists }}
      deployment-strategy: ${{ steps.check-infrastructure.outputs.strategy }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify Backend Health
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ” Verifying backend health..."
        
        # Check S3 bucket
        if aws s3 ls "s3://${{ env.STATE_BUCKET }}" > /dev/null 2>&1; then
          echo "âœ… S3 bucket accessible"
        else
          echo "âŒ S3 bucket not accessible"
          exit 1
        fi
        
        # Check DynamoDB table
        if aws dynamodb describe-table --table-name "${{ env.LOCK_TABLE }}" > /dev/null 2>&1; then
          echo "âœ… DynamoDB lock table exists"
        else
          echo "âŒ DynamoDB lock table missing"
          exit 1
        fi

    - name: Terraform Init with Backend
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Initializing Terraform with S3 backend..."
        terraform init -reconfigure \
          -backend-config="bucket=${{ env.STATE_BUCKET }}" \
          -backend-config="key=${{ env.STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ env.LOCK_TABLE }}" \
          -backend-config="encrypt=true"

    - name: Check and Handle State Lock
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ” Checking for existing state locks..."
        
        # Function to check if lock is stale (older than 15 minutes)
        check_stale_lock() {
          local lock_time=$1
          local current_time=$(date -u +%s)
          local lock_timestamp=$(date -d "$lock_time" +%s 2>/dev/null || echo "0")
          local age=$((current_time - lock_timestamp))
          
          # If lock is older than 15 minutes (900 seconds), consider it stale
          if [ $age -gt 900 ]; then
            return 0  # stale
          else
            return 1  # not stale
          fi
        }
        
        # Try to get state info to check for locks
        set +e
        terraform refresh -input=false > /dev/null 2>&1
        refresh_exit_code=$?
        set -e
        
        if [ $refresh_exit_code -eq 1 ]; then
          echo "ðŸ”’ State lock detected, checking if it's stale..."
          
          # Try to get lock info
          lock_output=$(terraform plan -input=false 2>&1 || true)
          
          if echo "$lock_output" | grep -q "Lock Info:"; then
            lock_id=$(echo "$lock_output" | grep "ID:" | awk '{print $2}')
            lock_time=$(echo "$lock_output" | grep "Created:" | sed 's/.*Created: *\(.*\) UTC.*/\1/')
            lock_who=$(echo "$lock_output" | grep "Who:" | awk '{print $2}')
            
            echo "ðŸ” Lock details:"
            echo "  ID: $lock_id"
            echo "  Created: $lock_time"
            echo "  Who: $lock_who"
            
            if check_stale_lock "$lock_time"; then
              echo "âš ï¸ Lock is stale (older than 15 minutes), force unlocking..."
              terraform force-unlock -force "$lock_id"
              echo "âœ… Stale lock removed successfully"
            else
              echo "âŒ Lock is recent, operation is likely in progress"
              echo "ðŸ• Waiting 60 seconds for operation to complete..."
              sleep 60
              
              # Check again after waiting
              set +e
              terraform refresh -input=false > /dev/null 2>&1
              second_check=$?
              set -e
              
              if [ $second_check -eq 1 ]; then
                echo "ðŸ”’ Lock still exists after waiting, force unlocking..."
                terraform force-unlock -force "$lock_id" || true
                echo "âœ… Lock forcefully removed"
              else
                echo "âœ… Lock cleared automatically"
              fi
            fi
          fi
        else
          echo "âœ… No state lock detected"
        fi

    - name: Set Terraform Environment Variables
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        
        # EC2 Configuration
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        
        # Networking Configuration
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        
        # S3 Configuration
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        
        # Container Configuration
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        
        # Domain Configuration
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        
        # Monitoring
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        
        # Secrets
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        
        # Application URLs
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        
        # Additional Configuration
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸ”§ Setting Terraform environment variables from GitHub secrets..."
        echo "âœ… All Terraform environment variables configured using GitHub Actions env context"
        echo "ðŸ“Š Environment: ${{ env.ENVIRONMENT }}"
        echo "ðŸ”’ Secrets and variables loaded as TF_VAR_* environment variables"
        
        # Verify some key variables are set
        echo "ðŸ” Verifying key environment variables..."
        echo "Region: ${TF_VAR_region:-NOT_SET}"
        echo "Environment: ${TF_VAR_environment:-NOT_SET}"
        echo "Project: ${TF_VAR_project_name:-NOT_SET}"
        echo "Instance Type: ${TF_VAR_instance_type:-NOT_SET}"
        
        # Verify problematic tag variables are not set
        echo "ðŸ” Verifying tag variables are not set..."
        if [ -n "${TF_VAR_tags:-}" ]; then
          echo "âš ï¸ WARNING: TF_VAR_tags is set: ${TF_VAR_tags}"
        else
          echo "âœ… TF_VAR_tags is not set (good)"
        fi
        
        if [ -n "${TF_VAR_common_tags:-}" ]; then
          echo "âš ï¸ WARNING: TF_VAR_common_tags is set: ${TF_VAR_common_tags}"
        else
          echo "âœ… TF_VAR_common_tags is not set (good)"
        fi

    - name: Set Boolean Environment Variables
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Setting boolean environment variables for Terraform..."
        
        # Convert string boolean values to proper booleans
        # GitHub Actions passes booleans as strings, so we need to convert them
        
        # Set use_default_vpc
        if [ "${{ vars.USE_DEFAULT_VPC || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_default_vpc=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_default_vpc=false" >> $GITHUB_ENV
        fi
        
        # Set s3_force_destroy
        if [ "${{ vars.S3_FORCE_DESTROY || 'false' }}" = "true" ]; then
          echo "TF_VAR_s3_force_destroy=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_s3_force_destroy=false" >> $GITHUB_ENV
        fi
        
        # Set use_postgres
        if [ "${{ vars.USE_POSTGRES || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_postgres=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_postgres=false" >> $GITHUB_ENV
        fi
        
        # Set start_ngrok
        if [ "${{ vars.START_NGROK || 'true' }}" = "true" ]; then
          echo "TF_VAR_start_ngrok=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_start_ngrok=false" >> $GITHUB_ENV
        fi
        
        # Set debug
        if [ "${{ vars.DEBUG || 'true' }}" = "true" ]; then
          echo "TF_VAR_debug=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_debug=false" >> $GITHUB_ENV
        fi
        
        # Set enable_carrental_domain (hardcoded to false)
        echo "TF_VAR_enable_carrental_domain=false" >> $GITHUB_ENV
        
        echo "âœ… Boolean environment variables set successfully!"

    - name: Check Infrastructure Existence & Determine Strategy
      id: check-infrastructure
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ” INTELLIGENT DEPLOYMENT STRATEGY DETECTION"
        echo "============================================="
        echo ""
        
        # Check if key infrastructure components exist
        INFRASTRUCTURE_EXISTS=false
        STRATEGY="full-deploy"
        
        echo "ðŸ” Checking for existing infrastructure components..."
        
        # Check for EC2 instance
        EC2_EXISTS=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-seller-connect-${{ env.ENVIRONMENT }}-ec2" "Name=instance-state-name,Values=running,stopped,stopping" \
          --query 'Reservations[*].Instances[*].InstanceId' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$EC2_EXISTS" ] && [ "$EC2_EXISTS" != "None" ]; then
          echo "âœ… EC2 instance found: $EC2_EXISTS"
          INFRASTRUCTURE_EXISTS=true
        else
          echo "âŒ No EC2 instance found"
        fi
        
        # Check for ALB
        ALB_EXISTS=$(aws elbv2 describe-load-balancers \
          --names "sms-seller-connect-${{ env.ENVIRONMENT }}-alb" \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$ALB_EXISTS" ] && [ "$ALB_EXISTS" != "None" ]; then
          echo "âœ… ALB found: $(basename $ALB_EXISTS)"
          INFRASTRUCTURE_EXISTS=true
        else
          echo "âŒ No ALB found"
        fi
        
        # Check for S3 bucket
        BUCKET_EXISTS=$(aws s3api head-bucket --bucket "sms-seller-connect-${{ env.ENVIRONMENT }}-bucket" 2>/dev/null && echo "true" || echo "false")
        
        if [ "$BUCKET_EXISTS" = "true" ]; then
          echo "âœ… S3 bucket found"
          INFRASTRUCTURE_EXISTS=true
        else
          echo "âŒ No S3 bucket found"
        fi
        
        # Check for Route53 hosted zone
        ROUTE53_EXISTS=$(aws route53 list-hosted-zones \
          --query "HostedZones[?Name=='${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}.'].Id" \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$ROUTE53_EXISTS" ] && [ "$ROUTE53_EXISTS" != "None" ]; then
          echo "âœ… Route53 hosted zone found"
        else
          echo "âŒ No Route53 hosted zone found"
        fi
        
        echo ""
        echo "ðŸŽ¯ DEPLOYMENT STRATEGY DECISION:"
        echo "==============================="
        
        if [ "$INFRASTRUCTURE_EXISTS" = "true" ]; then
          # Check if EC2 is running and accessible
          if [ -n "$EC2_EXISTS" ]; then
            EC2_STATE=$(aws ec2 describe-instances \
              --instance-ids "$EC2_EXISTS" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "")
            
            echo "ðŸ“Š EC2 Instance State: $EC2_STATE"
            
            if [ "$EC2_STATE" = "running" ]; then
              # Check if we can connect to the instance
              EC2_IP=$(aws ec2 describe-instances \
                --instance-ids "$EC2_EXISTS" \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$EC2_IP" ] && [ "$EC2_IP" != "None" ]; then
                echo "âœ… EC2 is running and accessible at $EC2_IP"
                STRATEGY="redeploy"
                echo "ðŸš€ STRATEGY: Fast Redeploy - Update existing running infrastructure"
              else
                STRATEGY="full-deploy"
                echo "ðŸ—ï¸ STRATEGY: Full Deploy - EC2 exists but not accessible"
              fi
            else
              STRATEGY="full-deploy"
              echo "ðŸ—ï¸ STRATEGY: Full Deploy - EC2 exists but not running ($EC2_STATE)"
            fi
          else
            STRATEGY="full-deploy"
            echo "ðŸ—ï¸ STRATEGY: Full Deploy - Some infrastructure exists but EC2 missing"
          fi
        else
          STRATEGY="full-deploy"
          echo "ðŸ—ï¸ STRATEGY: Full Deploy - No existing infrastructure detected"
        fi
        
        echo ""
        echo "ðŸ“‹ STRATEGY SUMMARY:"
        echo "==================="
        if [ "$STRATEGY" = "redeploy" ]; then
          echo "âœ¨ FAST REDEPLOY selected"
          echo "   â€¢ Infrastructure exists and is healthy"
          echo "   â€¢ Will update containers and configurations"
          echo "   â€¢ Estimated time: ~5 minutes"
          echo "   â€¢ Route: plan â†’ redeploy â†’ health-check"
        else
          echo "ðŸ—ï¸ FULL DEPLOYMENT selected"
          echo "   â€¢ Infrastructure missing or unhealthy"
          echo "   â€¢ Will create/recreate all resources"
          echo "   â€¢ Estimated time: ~15 minutes"
          echo "   â€¢ Route: plan â†’ apply â†’ health-check"
        fi
        
        # Set outputs
        echo "exists=$INFRASTRUCTURE_EXISTS" >> $GITHUB_OUTPUT
        echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
        
        echo ""
        echo "ðŸ”„ Next job will be: $([ "$STRATEGY" = "redeploy" ] && echo "Fast Redeploy" || echo "Full Apply")"

    - name: Terraform Plan
      id: plan
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        
        # EC2 Configuration
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        
        # Networking Configuration
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        
        # S3 Configuration
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        
        # Container Configuration
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        
        # Domain Configuration
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        
        # Monitoring
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        
        # Secrets
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        
        # Application URLs
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        
        # Additional Configuration
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸ“‹ Creating Terraform plan for ${{ env.ENVIRONMENT }} environment..."
        
        # Debug: Show some environment variables are set
        echo "ðŸ” DEBUG: Checking key variables..."
        echo "Environment: ${TF_VAR_environment:-NOT_SET}"
        echo "Project: ${TF_VAR_project_name:-NOT_SET}"
        echo "Region: ${TF_VAR_region:-NOT_SET}"
        echo "Instance Type: ${TF_VAR_instance_type:-NOT_SET}"
        
        # Debug: Verify problematic tag variables are not set
        echo "ðŸ” DEBUG: Verifying tag variables are not set..."
        if [ -n "${TF_VAR_tags:-}" ]; then
          echo "âŒ ERROR: TF_VAR_tags is set: ${TF_VAR_tags}"
        else
          echo "âœ… TF_VAR_tags is not set (good)"
        fi
        
        if [ -n "${TF_VAR_common_tags:-}" ]; then
          echo "âŒ ERROR: TF_VAR_common_tags is set: ${TF_VAR_common_tags}"
        else
          echo "âœ… TF_VAR_common_tags is not set (good)"
        fi

                 # Create plan with detailed exit codes and disable input prompts
         echo "ðŸš€ Starting terraform plan with timeout protection and auto-retry..."
         
         # Function to run terraform plan with retry on lock conflicts
         run_terraform_plan() {
           local attempt=1
           local max_attempts=3
           
           while [ $attempt -le $max_attempts ]; do
             echo "ðŸ“‹ Attempt $attempt/$max_attempts: Running terraform plan..."
             
             set +e
             timeout 300 terraform plan -input=false -detailed-exitcode -no-color -out=tfplan 2>&1 | tee plan_output.txt
             exit_code=$?
             set -e
            
            # Check if timeout occurred
            if [ $exit_code -eq 124 ]; then
              echo "âŒ Terraform plan timed out after 5 minutes"
              exit 1
            fi
            
            # Check for lock conflicts
            if grep -q "Error acquiring the state lock" plan_output.txt; then
              echo "ðŸ”’ Lock conflict detected on attempt $attempt"
              
              if [ $attempt -lt $max_attempts ]; then
                # Extract lock ID and force unlock
                lock_id=$(grep -A 20 "Lock Info:" plan_output.txt | grep "ID:" | awk '{print $2}' || echo "")
                if [ -n "$lock_id" ]; then
                  echo "ðŸ”“ Force unlocking stale lock: $lock_id"
                  terraform force-unlock -force "$lock_id" || true
                fi
                
                echo "â³ Waiting 30 seconds before retry..."
                sleep 30
                attempt=$((attempt + 1))
                continue
              else
                echo "âŒ Failed to acquire lock after $max_attempts attempts"
                exit 1
              fi
            else
              # Plan succeeded or failed for other reasons
              break
            fi
          done
          
          return $exit_code
        }
        
        # Run terraform plan with retry logic
        run_terraform_plan
        
        echo "ðŸ” DEBUG: Terraform plan exit code was: $exit_code"
        
        # Check for changes in plan output as backup detection method
        if grep -q "Plan: .* to add\|Plan: .* to change\|Plan: .* to destroy" plan_output.txt; then
          plan_has_changes=$(grep "Plan: " plan_output.txt | grep -v "Plan: 0 to add, 0 to change, 0 to destroy" | wc -l)
        else
          plan_has_changes=0
        fi
        
        echo "ðŸ” DEBUG: Plan changes detected in output: $plan_has_changes"
        
        # Check if there were validation errors (terraform exits with 1 for errors)
        if grep -q "Error:" plan_output.txt; then
          echo "âŒ Terraform validation errors detected"
          echo "status=error" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
          echo "ðŸ” Showing validation errors:"
          cat plan_output.txt
          exit 1
        fi
        
        case $exit_code in
          0)
            # Double-check for changes even with exit code 0 (terraform bug workaround)
            if [ "$plan_has_changes" -gt 0 ]; then
              echo "âš ï¸ Exit code 0 but changes detected in plan output - treating as changes"
              echo "status=changes-detected" >> $GITHUB_OUTPUT
              echo "has-changes=true" >> $GITHUB_OUTPUT
              echo "ðŸ“ Changes detected (exit code: $exit_code, but plan shows changes)"
            else
              echo "status=no-changes" >> $GITHUB_OUTPUT
              echo "has-changes=false" >> $GITHUB_OUTPUT
              echo "âœ… No changes detected (exit code: $exit_code)"
            fi
            ;;
          1)
            echo "status=error" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "âŒ Planning failed (exit code: $exit_code)"
            exit 1
            ;;
          2)
            echo "status=changes-detected" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "ðŸ“ Changes detected (exit code: $exit_code)"
            ;;
          *)
            echo "âš ï¸ Unexpected exit code: $exit_code - treating as error"
            echo "status=error" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 1
            ;;
        esac
        
        # Clean up temporary file
        rm -f plan_output.txt

    - name: Show Plan Summary
      if: steps.plan.outputs.has-changes == 'true'
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ“Š Infrastructure Plan Summary for ${{ env.ENVIRONMENT }}:"
        terraform show -no-color tfplan | head -50
        echo ""
        echo "ðŸ“ˆ Resource Changes:"
        terraform show -json tfplan | jq -r '.resource_changes[] | "\(.change.action | join(",")): \(.address)"' | sort | uniq -c

    - name: Upload Plan
      if: steps.plan.outputs.has-changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ env.ENVIRONMENT }}
        path: |
          ${{ env.TF_WORKING_DIR }}/tfplan
          ${{ env.TF_WORKING_DIR }}/terraform-${{ env.ENVIRONMENT }}.tfvars

  apply:
    name: 'ðŸ—ï¸ Full Infrastructure Deployment'
    runs-on: ubuntu-latest
    needs: [format, validate, plan]
    if: |
      needs.plan.outputs.deployment-strategy == 'full-deploy' && (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
        (github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.plan.outputs.has-changes == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan' && needs.plan.outputs.has-changes == 'true')
      )
    
    steps:
    - name: Auto-Deploy Notification
      run: |
        echo "ðŸš€ AUTO-DEPLOYMENT TRIGGERED!"
        echo "=============================="
        if [ "${{ github.event.inputs.action }}" = "plan" ]; then
          echo "ðŸŽ¯ Reason: Plan detected changes - proceeding to automatic deployment"
        elif [ "${{ github.event_name }}" = "push" ]; then
          echo "ðŸŽ¯ Reason: Push to main branch with infrastructure changes"
        else
          echo "ðŸŽ¯ Reason: Manual apply action requested"
        fi
        echo "ðŸ”§ Environment: ${{ env.ENVIRONMENT }}"
        echo "ðŸ“¦ Project: ${{ env.PROJECT_NAME }}"
        echo ""

    - name: Checkout
      uses: actions/checkout@v4

    - name: Validate Critical Secrets for Deployment
      run: |
        echo "ðŸ” Quick validation of critical secrets for deployment..."
        MISSING_SECRETS=0
        
        # Check absolutely critical secrets needed for deployment
        [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && echo "âŒ Missing AWS_ACCESS_KEY_ID" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ] && echo "âŒ Missing AWS_SECRET_ACCESS_KEY" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.SSH_PUBLIC_KEY }}" ] && echo "âŒ Missing SSH_PUBLIC_KEY" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.DB_HOST }}" ] && echo "âŒ Missing DB_HOST" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.DB_PASSWORD }}" ] && echo "âŒ Missing DB_PASSWORD" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.TWILIO_ACCOUNT_SID }}" ] && echo "âŒ Missing TWILIO_ACCOUNT_SID" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.OPENAI_API_KEY }}" ] && echo "âŒ Missing OPENAI_API_KEY" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        
        if [ $MISSING_SECRETS -gt 0 ]; then
          echo "âŒ DEPLOYMENT BLOCKED: $MISSING_SECRETS critical secrets are missing!"
          echo "This should not happen if plan validation passed. Check repository secrets configuration."
          exit 1
        else
          echo "âœ… All critical secrets available for deployment"
        fi

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download Plan
      if: needs.plan.outputs.has-changes == 'true'
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-${{ env.ENVIRONMENT }}
        path: ${{ env.TF_WORKING_DIR }}/

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Initializing Terraform..."
        terraform init -reconfigure \
          -backend-config="bucket=${{ env.STATE_BUCKET }}" \
          -backend-config="key=${{ env.STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ env.LOCK_TABLE }}" \
          -backend-config="encrypt=true"

    - name: Set Environment Variables for Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸ”§ Setting up environment variables for apply..."
        echo "âœ… All Terraform environment variables configured using GitHub Actions env context"

    - name: Set Boolean Environment Variables for Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Setting boolean environment variables for Terraform Apply..."
        
        # Set use_default_vpc
        if [ "${{ vars.USE_DEFAULT_VPC || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_default_vpc=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_default_vpc=false" >> $GITHUB_ENV
        fi
        
        # Set s3_force_destroy
        if [ "${{ vars.S3_FORCE_DESTROY || 'false' }}" = "true" ]; then
          echo "TF_VAR_s3_force_destroy=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_s3_force_destroy=false" >> $GITHUB_ENV
        fi
        
        # Set use_postgres
        if [ "${{ vars.USE_POSTGRES || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_postgres=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_postgres=false" >> $GITHUB_ENV
        fi
        
        # Set start_ngrok
        if [ "${{ vars.START_NGROK || 'true' }}" = "true" ]; then
          echo "TF_VAR_start_ngrok=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_start_ngrok=false" >> $GITHUB_ENV
        fi
        
        # Set debug
        if [ "${{ vars.DEBUG || 'true' }}" = "true" ]; then
          echo "TF_VAR_debug=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_debug=false" >> $GITHUB_ENV
        fi
        
        # Set enable_carrental_domain (hardcoded to false)
        echo "TF_VAR_enable_carrental_domain=false" >> $GITHUB_ENV
        
        echo "âœ… Boolean environment variables set for Apply!"

    - name: Terraform Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸš€ Applying Terraform changes for ${{ env.ENVIRONMENT }} environment..."
        echo "ðŸ“ Backend: s3://${{ env.STATE_BUCKET }}/${{ env.STATE_KEY }}"
        
                 if [ -f "tfplan" ]; then
           echo "ðŸ“‹ Applying saved plan..."
           terraform apply -auto-approve tfplan
         else
           echo "ðŸ“‹ Creating and applying new plan..."
           terraform apply -auto-approve
         fi
        
        echo "âœ… SMS Seller Connect infrastructure deployment completed!"

    - name: Get Infrastructure Outputs
      id: outputs
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ“Š Getting infrastructure outputs..."
        
        # Get EC2 outputs
        if terraform output instance_public_ip > /dev/null 2>&1; then
          INSTANCE_IP=$(terraform output -raw instance_public_ip 2>/dev/null || echo "N/A")
          echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
          echo "ðŸŒ Instance IP: ${INSTANCE_IP}"
        fi
        
        if terraform output instance_id > /dev/null 2>&1; then
          INSTANCE_ID=$(terraform output -raw instance_id 2>/dev/null || echo "N/A")
          echo "instance_id=${INSTANCE_ID}" >> $GITHUB_OUTPUT
          echo "ðŸ†” Instance ID: ${INSTANCE_ID}"
        fi
        
        # Get ALB outputs
        if terraform output alb_dns_name > /dev/null 2>&1; then
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "N/A")
          echo "alb_dns=${ALB_DNS}" >> $GITHUB_OUTPUT
          echo "ðŸ”— ALB DNS: ${ALB_DNS}"
        fi
        
        # Get S3 outputs
        if terraform output s3_bucket_name > /dev/null 2>&1; then
          BUCKET_NAME=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "N/A")
          echo "bucket_name=${BUCKET_NAME}" >> $GITHUB_OUTPUT
          echo "ðŸª£ Bucket Name: ${BUCKET_NAME}"
        fi
        
        # Get domain outputs
        if terraform output sms_frontend_url > /dev/null 2>&1; then
          FRONTEND_URL=$(terraform output -raw sms_frontend_url 2>/dev/null || echo "N/A")
          echo "frontend_url=${FRONTEND_URL}" >> $GITHUB_OUTPUT
          echo "ðŸŒ Frontend URL: ${FRONTEND_URL}"
        fi
        
        if terraform output sms_api_url > /dev/null 2>&1; then
          API_URL=$(terraform output -raw sms_api_url 2>/dev/null || echo "N/A")
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "ðŸ”— API URL: ${API_URL}"
        fi
        
        # Show all outputs
        echo "ðŸ“‹ All outputs:"
        terraform output 2>/dev/null || echo "â„¹ï¸ No outputs available"

    - name: Deployment Completion Summary
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "âœ… INFRASTRUCTURE DEPLOYMENT COMPLETED!"
        echo "======================================"
        echo ""
        echo "ðŸš€ Successfully deployed SMS Seller Connect infrastructure"
        echo "ðŸ“¦ Project: ${{ env.PROJECT_NAME }}"
        echo "ðŸŒ Environment: ${{ env.ENVIRONMENT }}"
        echo "â° Deployment completed at: $(date)"
        echo ""
        echo "ðŸ“‹ Infrastructure components deployed:"
        echo "  âœ… EC2 Instance"
        echo "  âœ… Application Load Balancer (ALB)"
        echo "  âœ… S3 Configuration Bucket"
        echo "  âœ… Route53 DNS Records"
        echo "  âœ… ACM SSL Certificates"
        echo "  âœ… Security Groups & Networking"
        echo "  âœ… CloudWatch Monitoring"
        echo ""
        echo "ðŸ”„ Next: Infrastructure Testing Stage will begin after stabilization period"
        echo "â³ Testing will start after 13-minute wait to allow all services to stabilize"
        echo ""
        echo "ðŸ“Š Check the 'Comprehensive Health Check' job for detailed verification results"

    - name: Update CloudWatch Dashboard
      run: |
        echo "ðŸ“Š Updating CloudWatch dashboard..."
        
        # Create/update CloudWatch dashboard for monitoring
        aws cloudwatch put-dashboard \
          --dashboard-name "SMS-Seller-Connect-${{ env.ENVIRONMENT }}" \
          --dashboard-body '{
            "widgets": [
              {
                "type": "metric",
                "properties": {
                  "metrics": [
                    ["AWS/EC2", "CPUUtilization", "InstanceId", "${{ steps.outputs.outputs.instance_id }}"],
                    [".", "NetworkIn", ".", "."],
                    [".", "NetworkOut", ".", "."]
                  ],
                  "period": 300,
                  "stat": "Average",
                  "region": "${{ env.AWS_REGION }}",
                  "title": "EC2 System Metrics"
                }
              },
              {
                "type": "metric",
                "properties": {
                  "metrics": [
                    ["AWS/ApplicationELB", "RequestCount", "LoadBalancer", "${{ steps.outputs.outputs.alb_dns }}"],
                    [".", "TargetResponseTime", ".", "."],
                    [".", "HTTPCode_Target_2XX_Count", ".", "."]
                  ],
                  "period": 300,
                  "stat": "Sum",
                  "region": "${{ env.AWS_REGION }}",
                  "title": "ALB Metrics"
                }
              }
            ]
          }' || echo "âš ï¸ Dashboard update failed, continuing..."

    - name: Display Deployment Results
      if: always()
      run: |
        echo "#### ðŸš€ SMS Seller Connect Deployment Results"
        echo ""
        echo "**Status**: ${{ job.status == 'success' && 'âœ… Successfully Deployed' || 'âŒ Deployment Failed' }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo "**Project**: ${{ env.PROJECT_NAME }}"
        echo ""
        echo "### ðŸŒ Application URLs:"
        echo "- **Frontend**: ${{ steps.outputs.outputs.frontend_url }}"
        echo "- **API**: ${{ steps.outputs.outputs.api_url }}"
        echo "- **Health Check**: ${{ steps.outputs.outputs.api_url }}/api/health"
        echo ""
        echo "### ðŸ—ï¸ Infrastructure Details:"
        echo "- **Instance IP**: ${{ steps.outputs.outputs.instance_ip }}"
        echo "- **Instance ID**: ${{ steps.outputs.outputs.instance_id }}"
        echo "- **ALB DNS**: ${{ steps.outputs.outputs.alb_dns }}"
        echo "- **S3 Bucket**: ${{ steps.outputs.outputs.bucket_name }}"
        echo "- **ECR Repository**: ${{ env.ECR_REPOSITORY }}"
        echo ""
        echo "### ðŸ“Š Monitoring Links:"
        echo "- **CloudWatch**: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=SMS-Seller-Connect-${{ env.ENVIRONMENT }}"
        echo "- **EC2 Console**: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#Instances:search=${{ steps.outputs.outputs.instance_id }}"
        echo "- **ALB Console**: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#LoadBalancers:"
        echo ""
        echo "### ðŸ”§ Features Deployed:"
        echo "- âœ… EC2 Instance with ALB multi-app architecture"
        echo "- âœ… Application Load Balancer with SSL termination"
        echo "- âœ… S3 bucket for configuration files"
        echo "- âœ… CloudWatch monitoring and logging"
        echo "- âœ… Route53 DNS records"
        echo "- âœ… ACM SSL certificates"
        echo "- âœ… Docker containerized applications"
        echo "- âœ… Nginx reverse proxy"

    - name: Display Route53 Name Servers
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸŒ Route53 Name Servers for Domain Configuration"
        echo "================================================"
        
        # Get the name servers from Terraform output
        if terraform output route53_name_servers > /dev/null 2>&1; then
          NAME_SERVERS=$(terraform output -raw route53_name_servers 2>/dev/null || echo "N/A")
          ZONE_ID=$(terraform output -raw route53_zone_id 2>/dev/null || echo "N/A")
          ZONE_NAME=$(terraform output -raw route53_zone_name 2>/dev/null || echo "N/A")
          
          echo "ðŸ“‹ **IMPORTANT**: Update your domain registrar with these name servers:"
          echo "ðŸ†” Zone ID: $ZONE_ID"
          echo "ðŸŒ Zone Name: $ZONE_NAME"
          echo ""
          echo "ðŸ“ Name Servers to configure with your registrar:"
          echo "$NAME_SERVERS" | sed 's/\[//g' | sed 's/\]//g' | sed 's/,/\n/g' | sed 's/"//g' | sed 's/^ *//g'
          echo ""
          echo "âš ï¸  **Domain will not resolve until name servers are updated with your registrar!**"
        else
          echo "âš ï¸ Could not retrieve Route53 name servers from Terraform output"
        fi


        
        if [ "$PASSED" -ge 5 ]; then
          echo "ðŸŽ‰ OVERALL STATUS: âœ… HEALTHY"
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo ""
          echo "ðŸŒŸ Your SMS Seller Connect application is running successfully!"
          echo ""
          echo "ðŸ”— Application URLs:"
          echo "   Frontend: ${{ steps.infra-details.outputs.frontend_url }}"
          echo "   API: ${{ steps.infra-details.outputs.api_url }}"
          echo "   ALB: ${{ steps.infra-details.outputs.alb_url }}"
        else
          echo "âš ï¸ OVERALL STATUS: âŒ UNHEALTHY"
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo ""
          echo "âŒ Some components are not functioning properly."
          echo "   Please review the test results above and check logs."
        fi
        
        # Save health summary
        echo "health_score=$PASSED/$TOTAL" >> $GITHUB_OUTPUT

    - name: Post Health Check Results to PR
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const healthStatus = '${{ steps.overall-health.outputs.status }}';
          const healthScore = '${{ steps.overall-health.outputs.health_score }}';
          const frontendUrl = '${{ steps.infra-details.outputs.frontend_url }}';
          const apiUrl = '${{ steps.infra-details.outputs.api_url }}';
          
          const emoji = healthStatus === 'healthy' ? 'ðŸŽ‰' : 'âš ï¸';
          const status = healthStatus === 'healthy' ? 'HEALTHY' : 'NEEDS ATTENTION';
          
          const comment = `## ${emoji} SMS Seller Connect Health Check Results
          
          **Overall Status**: ${status}  
          **Health Score**: ${healthScore}
          
          ### ðŸ” Component Status
          - ðŸ³ **Containers**: ${{ steps.container-health.outputs.status == 'success' && 'âœ… Healthy' || 'âŒ Issues detected' }}
          - ðŸ”§ **Backend API**: ${{ steps.backend-health.outputs.status == 'success' && 'âœ… Responding' || 'âŒ Not responding' }} (${{ steps.backend-health.outputs.backend_success_rate || 'N/A' }})
          - ðŸ¤– **AI Processing**: ${{ steps.ai-health.outputs.status == 'success' && 'âœ… Functional' || 'âŒ Not working' }}
          - ðŸ“± **SMS/Twilio**: ${{ steps.sms-health.outputs.status == 'success' && 'âœ… Operational' || 'âŒ Issues detected' }}
          - â° **Scheduler**: ${{ steps.scheduler-health.outputs.status == 'success' && 'âœ… Running' || 'âŒ Not running' }}
          - ðŸŽ¨ **Frontend**: ${{ steps.frontend-health.outputs.status == 'success' && 'âœ… Accessible' || 'âŒ Not accessible' }} (${{ steps.frontend-health.outputs.frontend_success_rate || 'N/A' }})
          - ðŸ—„ï¸ **Database**: ${{ steps.database-health.outputs.status == 'success' && 'âœ… Connected' || 'âŒ Connection issues' }}
          
          ### ðŸŒ Application URLs
          - **Frontend**: ${frontendUrl}
          - **API**: ${apiUrl}
          
          ${healthStatus === 'healthy' ? 
            'ðŸŽŠ **All systems are operational!** Your SMS Seller Connect application is ready for full use with AI processing, SMS communication, scheduled messages, and all features functional.' : 
            'âš ï¸ **Some issues detected.** Please review the detailed logs in the Actions tab to see which specific features need attention.'}
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

    - name: Health Check Summary
      if: always()
      run: |
        echo "#### ðŸ¥ SMS Seller Connect Comprehensive Health Check Summary"
        echo ""
        echo "**Overall Status**: ${{ steps.overall-health.outputs.status == 'healthy' && 'âœ… HEALTHY' || 'âš ï¸ NEEDS ATTENTION' }}"
        echo "**Health Score**: ${{ steps.overall-health.outputs.health_score }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo ""
        echo "**Feature Test Results**:"
        echo "- Containers: ${{ steps.container-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo "- Backend API: ${{ steps.backend-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo "- AI Processing: ${{ steps.ai-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo "- SMS/Twilio: ${{ steps.sms-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo "- Scheduler: ${{ steps.scheduler-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo "- Frontend: ${{ steps.frontend-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo "- Database: ${{ steps.database-health.outputs.status == 'success' && 'âœ…' || 'âŒ' }}"
        echo ""
        echo "**Application URLs**:"
        echo "- Frontend: ${{ steps.infra-details.outputs.frontend_url }}"
        echo "- API: ${{ steps.infra-details.outputs.api_url }}"
        echo "- ALB: ${{ steps.infra-details.outputs.alb_url }}"
        echo ""
        echo "${{ steps.overall-health.outputs.status == 'healthy' && 'ðŸŽ‰ **All SMS Seller Connect features operational!**' || 'âš ï¸ **Review required - check feature-specific logs above**' }}"

  destroy:
    name: 'ðŸ’¥ Destroy Infrastructure'
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Initializing Terraform..."
        terraform init -reconfigure \
          -backend-config="bucket=${{ env.STATE_BUCKET }}" \
          -backend-config="key=${{ env.STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ env.LOCK_TABLE }}" \
          -backend-config="encrypt=true"

    - name: Set Environment Variables for Destroy
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸ”§ Setting up environment variables for destroy..."
        echo "âœ… All Terraform environment variables configured using GitHub Actions env context"

    - name: Set Boolean Environment Variables for Destroy
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ”§ Setting boolean environment variables for Terraform Destroy..."
        
        # Set use_default_vpc
        if [ "${{ vars.USE_DEFAULT_VPC || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_default_vpc=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_default_vpc=false" >> $GITHUB_ENV
        fi
        
        # Set s3_force_destroy
        if [ "${{ vars.S3_FORCE_DESTROY || 'false' }}" = "true" ]; then
          echo "TF_VAR_s3_force_destroy=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_s3_force_destroy=false" >> $GITHUB_ENV
        fi
        
        # Set use_postgres
        if [ "${{ vars.USE_POSTGRES || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_postgres=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_postgres=false" >> $GITHUB_ENV
        fi
        
        # Set start_ngrok
        if [ "${{ vars.START_NGROK || 'true' }}" = "true" ]; then
          echo "TF_VAR_start_ngrok=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_start_ngrok=false" >> $GITHUB_ENV
        fi
        
        # Set debug
        if [ "${{ vars.DEBUG || 'true' }}" = "true" ]; then
          echo "TF_VAR_debug=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_debug=false" >> $GITHUB_ENV
        fi
        
        # Set enable_carrental_domain (hardcoded to false)
        echo "TF_VAR_enable_carrental_domain=false" >> $GITHUB_ENV
        
        echo "âœ… Boolean environment variables set for Destroy!"

    - name: Show Resources to be Destroyed
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸ” Resources that will be destroyed in ${{ env.ENVIRONMENT }}:"
        
        terraform state list
        echo ""
        echo "ðŸ“‹ Destroy plan:"
        terraform plan -destroy -no-color

    - name: Terraform Destroy
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "ðŸ’¥ Destroying SMS Seller Connect infrastructure in ${{ env.ENVIRONMENT }}..."
        
        terraform destroy -auto-approve
        
        echo "ðŸ—‘ï¸ Destruction completed!"

    - name: Display Destroy Results
      if: always()
      run: |
        echo "#### ðŸ’¥ SMS Seller Connect Infrastructure Destruction Results"
        echo ""
        echo "**Status**: ${{ job.status == 'success' && 'âœ… Successfully Destroyed' || 'âŒ Destruction Failed' }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo "**Project**: ${{ env.PROJECT_NAME }}"
        echo ""
        echo "${{ job.status == 'success' && 'âš ï¸ **All SMS Seller Connect infrastructure has been destroyed!**' || 'âŒ **Destruction failed - some resources may remain**' }}"
        echo ""
        echo "**Note**: State file preserved in S3 for audit purposes."

  verify-secrets:
    name: 'ðŸ” Verify GitHub Secrets & Variables'
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'verify-secrets'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Verify Required Secrets
      run: |
        echo "ðŸ” Verifying GitHub Secrets and Variables..."
        echo ""
        
        # Track missing secrets/variables
        missing_secrets=()
        missing_vars=()
        
        # Required Secrets
        echo "### Required Secrets:"
        secrets=(
          "AWS_ACCESS_KEY_ID"
          "AWS_SECRET_ACCESS_KEY"
          "SSH_PUBLIC_KEY"
          "DB_HOST"
          "DB_USER"
          "DB_PASSWORD"
          "FLASK_SECRET_KEY"
          "JWT_SECRET_KEY"
          "TWILIO_ACCOUNT_SID"
          "TWILIO_AUTH_TOKEN"
          "TWILIO_PHONE_NUMBER"
          "OPENAI_API_KEY"
          "SENDGRID_API_KEY"
          "NGROK_AUTH_TOKEN"
          "HOT_LEAD_SMS_RECIPIENTS"
        )
        
        for secret in "${secrets[@]}"; do
          case "$secret" in
            "AWS_ACCESS_KEY_ID")
              if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.AWS_ACCESS_KEY_ID }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "AWS_SECRET_ACCESS_KEY")
              if [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.AWS_SECRET_ACCESS_KEY }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "SSH_PUBLIC_KEY")
              if [ -n "${{ secrets.SSH_PUBLIC_KEY }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.SSH_PUBLIC_KEY }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "DB_HOST")
              if [ -n "${{ secrets.DB_HOST }}" ]; then
                echo "âœ… $secret - Set"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "DB_USER")
              if [ -n "${{ secrets.DB_USER }}" ]; then
                echo "âœ… $secret - Set"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "DB_PASSWORD")
              if [ -n "${{ secrets.DB_PASSWORD }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.DB_PASSWORD }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "FLASK_SECRET_KEY")
              if [ -n "${{ secrets.FLASK_SECRET_KEY }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.FLASK_SECRET_KEY }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "JWT_SECRET_KEY")
              if [ -n "${{ secrets.JWT_SECRET_KEY }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.JWT_SECRET_KEY }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "TWILIO_ACCOUNT_SID")
              if [ -n "${{ secrets.TWILIO_ACCOUNT_SID }}" ]; then
                echo "âœ… $secret - Set"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "TWILIO_AUTH_TOKEN")
              if [ -n "${{ secrets.TWILIO_AUTH_TOKEN }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.TWILIO_AUTH_TOKEN }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "TWILIO_PHONE_NUMBER")
              if [ -n "${{ secrets.TWILIO_PHONE_NUMBER }}" ]; then
                echo "âœ… $secret - Set"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "OPENAI_API_KEY")
              if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.OPENAI_API_KEY }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "SENDGRID_API_KEY")
              if [ -n "${{ secrets.SENDGRID_API_KEY }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.SENDGRID_API_KEY }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "NGROK_AUTH_TOKEN")
              if [ -n "${{ secrets.NGROK_AUTH_TOKEN }}" ]; then
                echo "âœ… $secret - Set (${#{{ secrets.NGROK_AUTH_TOKEN }}} chars)"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "HOT_LEAD_SMS_RECIPIENTS")
              if [ -n "${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}" ]; then
                echo "âœ… $secret - Set"
              else
                echo "âŒ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
          esac
        done
        
        echo ""
        echo "### Required Variables:"
        variables=(
          "BACKEND_IMAGE"
          "FRONTEND_IMAGE"
          "SMS_FRONTEND_DOMAIN"
          "SMS_API_DOMAIN"
          "SENDGRID_FROM_EMAIL"
          "DB_PORT"
          "DB_NAME"
        )
        
        for var in "${variables[@]}"; do
          case "$var" in
            "BACKEND_IMAGE")
              if [ -n "${{ vars.BACKEND_IMAGE }}" ]; then
                echo "âœ… $var - ${{ vars.BACKEND_IMAGE }}"
              else
                echo "âš ï¸ $var - Using fallback: 522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}"
              fi
              ;;
            "FRONTEND_IMAGE")
              if [ -n "${{ vars.FRONTEND_IMAGE }}" ]; then
                echo "âœ… $var - ${{ vars.FRONTEND_IMAGE }}"
              else
                echo "âš ï¸ $var - Using fallback: 522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}"
              fi
              ;;
            "SMS_FRONTEND_DOMAIN")
              if [ -n "${{ vars.SMS_FRONTEND_DOMAIN }}" ]; then
                echo "âœ… $var - ${{ vars.SMS_FRONTEND_DOMAIN }}"
              else
                echo "âš ï¸ $var - Using fallback: sms.typerelations.com"
              fi
              ;;
            "SMS_API_DOMAIN")
              if [ -n "${{ vars.SMS_API_DOMAIN }}" ]; then
                echo "âœ… $var - ${{ vars.SMS_API_DOMAIN }}"
              else
                echo "âš ï¸ $var - Using fallback: api.sms.typerelations.com"
              fi
              ;;
            "SENDGRID_FROM_EMAIL")
              if [ -n "${{ vars.SENDGRID_FROM_EMAIL }}" ]; then
                echo "âœ… $var - ${{ vars.SENDGRID_FROM_EMAIL }}"
              else
                echo "âš ï¸ $var - Using fallback: noreply@typerelations.com"
              fi
              ;;
            "DB_PORT")
              if [ -n "${{ vars.DB_PORT }}" ]; then
                echo "âœ… $var - ${{ vars.DB_PORT }}"
              else
                echo "âš ï¸ $var - Using fallback: 5437"
              fi
              ;;
            "DB_NAME")
              if [ -n "${{ vars.DB_NAME }}" ]; then
                echo "âœ… $var - ${{ vars.DB_NAME }}"
              else
                echo "âš ï¸ $var - Using fallback: sms_blast"
              fi
              ;;
          esac
        done
        
        echo ""
        echo "### Summary:"
        if [ ${#missing_secrets[@]} -eq 0 ] && [ ${#missing_vars[@]} -eq 0 ]; then
          echo "ðŸŽ‰ All required secrets and variables are configured!"
        else
          echo "âŒ Missing configuration:"
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "Missing secrets: ${missing_secrets[*]}"
          fi
          if [ ${#missing_vars[@]} -gt 0 ]; then
            echo "Missing variables: ${missing_vars[*]}"
          fi
          exit 1
        fi

  redeploy:
    name: 'ðŸš€ Fast Redeploy Application'
    runs-on: ubuntu-latest
    needs: [format, validate, plan]
    if: |
      needs.plan.outputs.deployment-strategy == 'redeploy' && (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
        (github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.plan.outputs.has-changes == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan' && needs.plan.outputs.has-changes == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'redeploy')
      )
    
    steps:
    - name: Fast Redeploy Strategy Notification
      run: |
        echo "ðŸš€ FAST REDEPLOY STRATEGY ACTIVATED!"
        echo "====================================="
        echo ""
        echo "âœ¨ Infrastructure already exists and is healthy"
        echo "ðŸŽ¯ Strategy: Update existing running infrastructure"
        echo "âš¡ Estimated time: ~5 minutes (vs ~15 minutes for full deployment)"
        echo ""
        echo "ðŸ”„ What will be updated:"
        echo "  â€¢ Container images (backend & frontend)"
        echo "  â€¢ Environment configurations"
        echo "  â€¢ Application configurations"
        echo "  â€¢ Service restarts"
        echo ""
        echo "ðŸ—ï¸ What will NOT be changed:"
        echo "  â€¢ EC2 instance (already running)"
        echo "  â€¢ ALB configuration (already configured)"
        echo "  â€¢ Route53 DNS (already set)"
        echo "  â€¢ Security groups (already configured)"
        echo ""
        echo "ðŸ”§ Environment: ${{ env.ENVIRONMENT }}"
        echo "ðŸ“¦ Project: ${{ env.PROJECT_NAME }}"
        echo ""

    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Upload All Latest Scripts and Configuration to S3
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "ðŸ“¤ Uploading ALL latest scripts and configuration to S3..."
        echo "This ensures the redeploy uses the newest versions from this commit"
        
        S3_BUCKET="sms-seller-connect-bucket"
        
        # Upload all scripts from the scripts directory
        echo "ðŸ”„ Uploading all scripts..."
        if [ -d "scripts" ]; then
          aws s3 sync scripts/ s3://${S3_BUCKET}/scripts/ --delete
          echo "âœ… All scripts uploaded and old scripts removed"
        else
          echo "âš ï¸ Scripts directory not found"
        fi
        
        # Upload docker-compose configuration
        echo "ðŸ”„ Uploading Docker Compose configuration..."
        if [ -f "config/docker-compose.yml" ]; then
          aws s3 cp config/docker-compose.yml s3://${S3_BUCKET}/docker-compose/docker-compose.yml
          echo "âœ… Docker Compose configuration uploaded"
        else
          echo "âš ï¸ Docker Compose configuration not found"
        fi
        
        # Upload environment template
        if [ -f "config/.env.template" ]; then
          aws s3 cp config/.env.template s3://${S3_BUCKET}/docker-compose/.env.template
          echo "âœ… Environment template uploaded"
        else
          echo "â„¹ï¸ Environment template not found (optional)"
        fi
        
        # Upload nginx configuration
        echo "ðŸ”„ Uploading Nginx configuration..."
        if [ -f "config/nginx.conf" ]; then
          aws s3 cp config/nginx.conf s3://${S3_BUCKET}/nginx/nginx.conf
          echo "âœ… Nginx configuration uploaded"
        else
          echo "âš ï¸ Nginx configuration not found"
        fi
        
        echo ""
        echo "ðŸ“‹ S3 Upload Summary:"
        echo "=============================="
        echo "ðŸ”§ Scripts: s3://${S3_BUCKET}/scripts/"
        echo "ðŸ³ Docker Compose: s3://${S3_BUCKET}/docker-compose/"
        echo "ðŸŒ Nginx Config: s3://${S3_BUCKET}/nginx/"
        echo ""
        echo "âœ… All latest files uploaded to S3 for redeploy"

    - name: Get EC2 Instance Details
      id: ec2-details
      run: |
        echo "ðŸ” Getting EC2 instance details..."
        
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-seller-connect-${{ env.ENVIRONMENT }}-ec2" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "âŒ No running EC2 instance found for environment: ${{ env.ENVIRONMENT }}"
          exit 1
        fi
        
        INSTANCE_IP=$(aws ec2 describe-instances \
          --instance-ids "$INSTANCE_ID" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "âœ… Found EC2 instance:"
        echo "Instance ID: $INSTANCE_ID"
        echo "Public IP: $INSTANCE_IP"
        
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: Execute Redeployment via SSM
      run: |
        echo "ðŸš€ Executing redeployment on EC2 instance..."
        
        # Create the redeployment command with all environment variables
        COMMAND=$(cat << 'EOF'
        #!/bin/bash
        set -e
        
        # Export all environment variables for the redeployment script
        export AWS_REGION="${{ env.AWS_REGION }}"
        export S3_BUCKET="sms-seller-connect-bucket"
        export ENVIRONMENT="${{ env.ENVIRONMENT }}"
        
        # Docker Images
        export BACKEND_IMAGE="${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}"
        export FRONTEND_IMAGE="${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}"
        
        # Domain Configuration
        export SMS_API_DOMAIN="${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}"
        export SMS_FRONTEND_DOMAIN="${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}"
        
        # Database Configuration
        export DB_HOST="${{ secrets.DB_HOST }}"
        export DB_PORT="${{ vars.DB_PORT || '5437' }}"
        export DB_NAME="${{ vars.DB_NAME || 'sms_blast' }}"
        export DB_USER="${{ secrets.DB_USER }}"
        export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
        
        # Application Configuration
        export SECRET_KEY="${{ secrets.FLASK_SECRET_KEY }}"
        export JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
        export TWILIO_ACCOUNT_SID="${{ secrets.TWILIO_ACCOUNT_SID }}"
        export TWILIO_AUTH_TOKEN="${{ secrets.TWILIO_AUTH_TOKEN }}"
        export TWILIO_PHONE_NUMBER="${{ secrets.TWILIO_PHONE_NUMBER }}"
        export OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
        export OPENAI_MODEL="${{ vars.OPENAI_MODEL || 'gpt-4o' }}"
        export OPENAI_TEMPERATURE="${{ vars.OPENAI_TEMPERATURE || '0.3' }}"
        
        # SendGrid Configuration
        export SENDGRID_API_KEY="${{ secrets.SENDGRID_API_KEY }}"
        export SENDGRID_FROM_EMAIL="${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}"
        
        # AWS Configuration
        export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
        export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        export S3_BUCKET_NAME="${{ vars.S3_BUCKET_NAME || 'grey-database-bucket' }}"
        
        # Hot Lead Configuration
        export HOT_LEAD_EMAIL_RECIPIENTS="${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}"
        export HOT_LEAD_SMS_RECIPIENTS="${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}"
        
        # Rate Limiting
        export RATE_LIMIT_PER_MINUTE="${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}"
        export RATE_LIMIT_BURST="${{ vars.RATE_LIMIT_BURST || '200' }}"
        
        # Session Configuration
        export SESSION_TIMEOUT_MINUTES="${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}"
        export REMEMBER_ME_DAYS="${{ vars.REMEMBER_ME_DAYS || '30' }}"
        
        # File Upload Configuration
        export MAX_FILE_SIZE_MB="${{ vars.MAX_FILE_SIZE_MB || '10' }}"
        export ALLOWED_FILE_TYPES="${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}"
        
        # Download diagnostic and redeployment scripts
        echo "ðŸ“¥ Downloading diagnostic and redeployment scripts..."
        aws s3 cp s3://sms-seller-connect-bucket/scripts/debug-redeploy.sh /tmp/debug-redeploy.sh
        aws s3 cp s3://sms-seller-connect-bucket/scripts/redeploy-application.sh /tmp/redeploy-application.sh
        chmod +x /tmp/debug-redeploy.sh /tmp/redeploy-application.sh
        
        echo "ðŸ” Running pre-deployment diagnostics..."
        /tmp/debug-redeploy.sh || {
          echo "âš ï¸ Pre-deployment diagnostics completed with warnings"
        }
        
        echo ""
        echo "ðŸš€ Executing redeployment..."
        if /tmp/redeploy-application.sh; then
          echo "âœ… Redeployment completed successfully"
          
          echo ""
          echo "ðŸ” Running post-deployment verification..."
          /tmp/debug-redeploy.sh || echo "âš ï¸ Post-deployment diagnostics completed with warnings"
        else
          REDEPLOY_EXIT_CODE=\$?
          echo "âŒ Redeployment failed with exit code \$REDEPLOY_EXIT_CODE"
          
          echo ""
          echo "ðŸ” Running failure diagnostics..."
          /tmp/debug-redeploy.sh || echo "âš ï¸ Failure diagnostics completed with warnings"
          
          echo ""
          echo "ðŸ“‹ Additional failure information:"
          echo "  - Exit code: \$REDEPLOY_EXIT_CODE"
          echo "  - Timestamp: \$(date)"
          echo "  - Instance: \$(curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null || echo 'unknown')"
          echo "  - Region: \$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.\$/' || echo 'unknown')"
          
          # Try to get recent system logs
          echo ""
          echo "ðŸ“œ Recent system logs:"
          sudo journalctl --no-pager --lines=50 --since="10 minutes ago" || echo "Cannot access system logs"
          
          # Try to get Docker logs if available
          echo ""
          echo "ðŸ³ Docker status:"
          sudo docker ps -a 2>/dev/null || echo "Cannot access Docker"
          
          if [ -d "/app/sms-seller-connect" ]; then
            echo ""
            echo "ðŸ“¦ Application status:"
            cd /app/sms-seller-connect
            sudo docker-compose ps 2>/dev/null || echo "Cannot access Docker Compose"
            sudo docker-compose logs --tail=50 2>/dev/null || echo "Cannot access Docker Compose logs"
          fi
          
          exit \$REDEPLOY_EXIT_CODE
        fi
        EOF
        )
        
        # Execute the command via SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ steps.ec2-details.outputs.instance_id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$COMMAND\"]" \
          --comment "SMS Seller Connect Application Redeployment" \
          --query 'Command.CommandId' \
          --output text)
        
        echo "ðŸ“‹ SSM Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "â³ Waiting for redeployment to complete..."
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2-details.outputs.instance_id }}"
        
        # Get command output
        echo "ðŸ“Š Redeployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2-details.outputs.instance_id }}" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check if command succeeded
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2-details.outputs.instance_id }}" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "ðŸŽ‰ Redeployment completed successfully!"
        else
          echo "âŒ Redeployment failed with status: $STATUS"
          echo "Error output:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.ec2-details.outputs.instance_id }}" \
            --query 'StandardErrorContent' \
            --output text
          exit 1
        fi

    - name: Verify Application Health
      run: |
        echo "ðŸ” Verifying application health..."
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names "sms-seller-connect-${{ env.ENVIRONMENT }}-alb" \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        if [ "$ALB_DNS" != "None" ] && [ "$ALB_DNS" != "null" ]; then
          echo "ðŸŒ Testing ALB health endpoint..."
          
          # Test ALB health endpoint with retries
          for i in {1..10}; do
            if curl -f -s "http://$ALB_DNS/alb-health" > /dev/null; then
              echo "âœ… ALB health check passed"
              break
            else
              if [ $i -eq 10 ]; then
                echo "âŒ ALB health check failed after 10 attempts"
              else
                echo "â³ Attempt $i/10 failed, retrying in 30s..."
                sleep 30
              fi
            fi
          done
        fi
        
        echo "ðŸŽ‰ Application redeployment verification completed!"

    - name: Display Redeployment Results
      if: always()
      run: |
        echo "#### ðŸš€ SMS Seller Connect Application Redeployment Results"
        echo ""
        echo "**Status**: ${{ job.status == 'success' && 'âœ… Successfully Redeployed' || 'âŒ Redeployment Failed' }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo "**Instance ID**: ${{ steps.ec2-details.outputs.instance_id }}"
        echo "**Instance IP**: ${{ steps.ec2-details.outputs.instance_ip }}"
        echo ""
        echo "**Frontend URL**: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}"
        echo "**API URL**: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}"
        echo ""
        echo "${{ job.status == 'success' && 'ðŸŽ‰ **Application has been successfully redeployed without infrastructure changes!**' || 'âŒ **Redeployment failed - check logs for details**' }}"

  health-check:
    name: 'ðŸ§ª Test Infrastructure & Application Health'
    runs-on: ubuntu-latest
    needs: [apply, redeploy]
    if: |
      always() && (
        (needs.apply.result == 'success') ||
        (needs.redeploy.result == 'success')
      )
    
    outputs:
      health-status: ${{ steps.overall-health.outputs.status }}
      backend-status: ${{ steps.backend-health.outputs.status }}
      frontend-status: ${{ steps.frontend-health.outputs.status }}
      container-status: ${{ steps.container-health.outputs.status }}
      ai-status: ${{ steps.ai-health.outputs.status }}
      sms-status: ${{ steps.sms-health.outputs.status }}
      scheduler-status: ${{ steps.scheduler-health.outputs.status }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Infrastructure Deployment Complete - Begin Stabilization
      run: |
        echo "ðŸš€ Infrastructure deployment completed!"
        echo "======================================"
        echo "â³ Beginning extended stabilization period..."
        echo ""
        echo "ðŸ“‹ What's happening during this wait:"
        echo "  1. EC2 instance completing boot process"
        echo "  2. User data scripts executing (Docker setup, service config)"
        echo "  3. Container images being pulled from ECR"
        echo "  4. Database connections being established"
        echo "  5. Backend API services initializing"
        echo "  6. AI processing services loading models"
        echo "  7. SMS/Twilio services connecting"
        echo "  8. Scheduler services starting"
        echo "  9. Frontend application building"
        echo "  10. All health checks becoming responsive"
        echo ""
        echo "â° EXTENDED STABILIZATION: 10 MINUTES"
        echo "This is intentionally long to ensure all complex services are fully operational."
        echo ""
        echo "Starting stabilization wait at $(date)..."
        sleep 600
        echo "âœ… Extended stabilization period complete (10 minutes) - $(date)"

    - name: Get Infrastructure Details
      id: infra-details
      run: |
        echo "ðŸ” Gathering infrastructure details..."
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names "sms-seller-connect-${{ env.ENVIRONMENT }}-alb" \
          --query 'LoadBalancers[0].DNSName' \
          --output text 2>/dev/null || echo "not-found")
        
        # Get EC2 instance details
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-seller-connect-${{ env.ENVIRONMENT }}-ec2" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text 2>/dev/null || echo "not-found")
        
        INSTANCE_IP=$(aws ec2 describe-instances \
          --instance-ids "$INSTANCE_ID" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text 2>/dev/null || echo "not-found")
        
        echo "ðŸ“Š Infrastructure Details:"
        echo "ALB DNS: $ALB_DNS"
        echo "Instance ID: $INSTANCE_ID"
        echo "Instance IP: $INSTANCE_IP"
        
        echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
        
        # Set up base URLs for testing
        echo "frontend_url=https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}" >> $GITHUB_OUTPUT
        echo "api_url=https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}" >> $GITHUB_OUTPUT
        echo "alb_url=http://$ALB_DNS" >> $GITHUB_OUTPUT

    - name: Final Service Readiness Check
      run: |
        echo "ðŸ” Final service readiness verification before comprehensive testing..."
        echo "â³ Allowing additional 3 minutes for all services to reach fully stable state..."
        echo ""
        echo "ðŸŽ¯ This final wait ensures:"
        echo "  - All containers are not just running, but fully responsive"
        echo "  - Database connections are stable and performant"
        echo "  - API endpoints are responding consistently"
        echo "  - AI services have completed model loading"
        echo "  - Background services are operational"
        echo ""
        echo "Starting final readiness wait at $(date)..."
        sleep 180
        echo "âœ… Final readiness verification complete (3 minutes) - $(date)"
        echo ""
        echo "ðŸš€ TOTAL STABILIZATION TIME: 13 MINUTES"
        echo "Now beginning comprehensive infrastructure testing..."

    - name: Test Backend API Endpoints & Features
      id: backend-health
      run: |
        echo "ðŸ”§ Testing Backend API Endpoints & Features..."
        
        API_URL="${{ steps.infra-details.outputs.api_url }}"
        ALB_URL="${{ steps.infra-details.outputs.alb_url }}"
        SUCCESS_COUNT=0
        TOTAL_TESTS=0
        
        # Function to test endpoint
        test_endpoint() {
          local url="$1"
          local name="$2"
          local expected_status="${3:-200}"
          local method="${4:-GET}"
          local data="${5:-}"
          
          echo "Testing $name: $method $url"
          TOTAL_TESTS=$((TOTAL_TESTS + 1))
          
          if [ "$method" = "POST" ] && [ -n "$data" ]; then
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 -X POST -H "Content-Type: application/json" -d "$data" "$url")
          else
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 -X "$method" "$url")
          fi
          
          http_code=$(echo "$response" | grep "HTTPSTATUS:" | cut -d: -f2)
          body=$(echo "$response" | sed 's/HTTPSTATUS:.*//g')
          
          if [ "$http_code" -eq "$expected_status" ] || [ "$http_code" -eq 200 ]; then
            echo "âœ… $name - HTTP $http_code"
            if [ -n "$body" ]; then
              echo "   Response: $(echo "$body" | head -c 200)..."
            fi
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "âŒ $name - HTTP $http_code"
            if [ -n "$body" ]; then
              echo "   Error: $(echo "$body" | head -c 200)..."
            fi
          fi
          echo ""
        }
        
        echo "ðŸ¥ CORE HEALTH ENDPOINTS:"
        echo "========================"
        test_endpoint "$API_URL/health" "Primary Health Check"
        test_endpoint "$API_URL/api/health" "Extended Health Check"
        test_endpoint "$API_URL/" "API Root"
        
        echo "ðŸ” AUTHENTICATION SYSTEM:"
        echo "========================="
        test_endpoint "$API_URL/api/auth/login" "Login Endpoint" 405 "POST"
        test_endpoint "$API_URL/api/auth/register" "Registration Endpoint" 405 "POST"
        test_endpoint "$API_URL/api/auth/logout" "Logout Endpoint" 401 "POST"
        test_endpoint "$API_URL/api/auth/refresh" "Token Refresh" 401 "POST"
        
        echo "ðŸ“± SMS & COMMUNICATION:"
        echo "======================="
        test_endpoint "$API_URL/api/sms/send" "SMS Send Endpoint" 401 "POST"
        test_endpoint "$API_URL/api/sms/status" "SMS Status Check" 401
        test_endpoint "$API_URL/api/webhooks/sms" "SMS Webhook Endpoint" 405 "POST"
        test_endpoint "$API_URL/api/messages" "Messages Management" 401
        test_endpoint "$API_URL/api/messages/search" "Message Search" 401
        
        echo "ðŸ‘¤ LEAD MANAGEMENT:"
        echo "=================="
        test_endpoint "$API_URL/api/leads" "Leads Endpoint" 401
        test_endpoint "$API_URL/api/leads/search" "Lead Search" 401
        test_endpoint "$API_URL/api/leads/import" "Lead Import" 401 "POST"
        test_endpoint "$API_URL/api/leads/export" "Lead Export" 401
        test_endpoint "$API_URL/api/leads/stats" "Lead Statistics" 401
        
        echo "ðŸ¤– AI PROCESSING:"
        echo "================="
        test_endpoint "$API_URL/api/ai/process" "AI Message Processing" 401 "POST"
        test_endpoint "$API_URL/api/ai/status" "AI Service Status" 401
        test_endpoint "$API_URL/api/ai/settings" "AI Configuration" 401
        
        echo "â° SCHEDULED MESSAGES:"
        echo "====================="
        test_endpoint "$API_URL/api/scheduler/status" "Scheduler Status" 401
        test_endpoint "$API_URL/api/scheduler/jobs" "Scheduled Jobs" 401
        test_endpoint "$API_URL/api/scheduler/create" "Create Schedule" 401 "POST"
        
        echo "ðŸ“Š ANALYTICS & REPORTING:"
        echo "========================"
        test_endpoint "$API_URL/api/analytics" "Analytics Dashboard" 401
        test_endpoint "$API_URL/api/analytics/messages" "Message Analytics" 401
        test_endpoint "$API_URL/api/analytics/leads" "Lead Analytics" 401
        test_endpoint "$API_URL/api/analytics/performance" "Performance Metrics" 401
        test_endpoint "$API_URL/api/reports/generate" "Report Generation" 401 "POST"
        
        echo "ðŸ“ FILE MANAGEMENT:"
        echo "=================="
        test_endpoint "$API_URL/api/files/upload" "File Upload Endpoint" 401 "POST"
        test_endpoint "$API_URL/api/files/list" "File Listing" 401
        test_endpoint "$API_URL/api/files/download" "File Download" 401
        
        echo "âš™ï¸ SYSTEM MANAGEMENT:"
        echo "===================="
        test_endpoint "$API_URL/api/system/status" "System Status" 401
        test_endpoint "$API_URL/api/system/logs" "System Logs" 401
        test_endpoint "$API_URL/api/system/config" "System Configuration" 401
        test_endpoint "$API_URL/api/alerts" "Alert System" 401
        
        echo "ðŸ“š DOCUMENTATION:"
        echo "================="
        test_endpoint "$API_URL/api/docs" "API Documentation"
        test_endpoint "$API_URL/api/openapi.json" "OpenAPI Schema"
        test_endpoint "$API_URL/redoc" "ReDoc Documentation"
        
        # Test via ALB as backup if many direct API calls failed
        if [ "$SUCCESS_COUNT" -lt 10 ]; then
          echo ""
          echo "ðŸ”„ BACKUP TESTING VIA ALB:"
          echo "========================="
          test_endpoint "$ALB_URL/health" "ALB Backend Health"
          test_endpoint "$ALB_URL/api/health" "ALB Backend API Health"
          test_endpoint "$ALB_URL/api/docs" "ALB API Documentation"
        fi
        
        echo ""
        echo "ðŸ“Š BACKEND ENDPOINT SUMMARY:"
        echo "============================"
        echo "Total endpoints tested: $TOTAL_TESTS"
        echo "Successful responses: $SUCCESS_COUNT"
        echo "Success rate: $(( SUCCESS_COUNT * 100 / TOTAL_TESTS ))%"
        
        echo "backend_success_rate=$SUCCESS_COUNT/$TOTAL_TESTS" >> $GITHUB_OUTPUT
        
        # More lenient success criteria for comprehensive testing
        if [ "$SUCCESS_COUNT" -ge 10 ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Backend comprehensive health check PASSED ($SUCCESS_COUNT/$TOTAL_TESTS endpoints responding)"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "âŒ Backend comprehensive health check FAILED ($SUCCESS_COUNT/$TOTAL_TESTS endpoints responding)"
        fi

    - name: Test AI Processing Services
      id: ai-health
      run: |
        echo "ðŸ¤– Testing AI Processing Services..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        if [ "$INSTANCE_ID" = "not-found" ]; then
          echo "âŒ No EC2 instance found for AI testing"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Create AI service test script
        AI_TEST_SCRIPT='#!/bin/bash
        echo "ðŸ¤– AI PROCESSING SERVICE TEST"
        echo "============================"
        echo ""
        
        # Test AI service functionality within backend container
        echo "Testing AI service components..."
        
        if docker exec sms_backend python3 -c "
        import sys
        sys.path.append('\''/app'\'')
        
        try:
            # Test AI imports
            from src.ai.processor import AIProcessor
            from src.ai.message_analyzer import MessageAnalyzer
            print('\'âœ… AI modules import successfully'\'')
            
            # Test AI configuration
            ai_processor = AIProcessor()
            print('\'âœ… AI processor initialized'\'')
            
            # Test message analyzer
            analyzer = MessageAnalyzer()
            print('\'âœ… Message analyzer initialized'\'')
            
            # Test basic AI functionality (without API calls)
            test_message = '\''Hello, I am interested in your property'\''
            result = analyzer.analyze_sentiment(test_message)
            print(f'\'âœ… AI sentiment analysis working: {result}'\'')
            
        except Exception as e:
            print(f'\'âŒ AI service test failed: {e}'\'')
            import traceback
            traceback.print_exc()
            exit(1)
        " 2>&1; then
          echo "âœ… AI processing services are functional"
        else
          echo "âŒ AI processing services failed"
          echo "Checking AI-related logs..."
          docker logs --tail 20 sms_backend | grep -i -E "(ai|openai|gpt|nlp)" || echo "No AI-related logs found"
        fi
        
        echo ""
        echo "ðŸ” AI Configuration Check:"
        docker exec sms_backend env | grep -E "^(OPENAI_|AI_|GPT_)" | sed "s/=.*/=***HIDDEN***/" || echo "No AI environment variables found"'
        
        # Execute AI test via SSM
        echo "ðŸš€ Executing AI functionality test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$AI_TEST_SCRIPT\"]" \
          --comment "AI Processing Service Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 20
        
        # Get and display results
        echo "ðŸ“Š AI Service Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… AI processing services test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "âŒ AI processing services test failed"
        fi

    - name: Test SMS & Twilio Services  
      id: sms-health
      run: |
        echo "ðŸ“± Testing SMS & Twilio Services..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        # Create SMS service test script
        SMS_TEST_SCRIPT='#!/bin/bash
        echo "ðŸ“± SMS & TWILIO SERVICE TEST"
        echo "==========================="
        echo ""
        
        # Test SMS service functionality within backend container
        echo "Testing SMS service components..."
        
        if docker exec sms_backend python3 -c "
        import sys
        sys.path.append('\''/app'\'')
        
        try:
            # Test SMS imports
            from src.sms.twilio_client import TwilioClient
            from src.sms.message_handler import MessageHandler
            print('\'âœ… SMS modules import successfully'\'')
            
            # Test SMS configuration
            twilio_client = TwilioClient()
            print('\'âœ… Twilio client initialized'\'')
            
            # Test message handler
            handler = MessageHandler()
            print('\'âœ… Message handler initialized'\'')
            
            # Test Twilio credentials (without sending)
            if hasattr(twilio_client, '\''client'\'') and twilio_client.client:
                print('\'âœ… Twilio credentials configured'\'')
            else:
                print('\'âš ï¸ Twilio credentials may not be configured'\'')
                
        except Exception as e:
            print(f'\'âŒ SMS service test failed: {e}'\'')
            import traceback
            traceback.print_exc()
            exit(1)
        " 2>&1; then
          echo "âœ… SMS services are functional"
        else
          echo "âŒ SMS services failed"
          echo "Checking SMS-related logs..."
          docker logs --tail 20 sms_backend | grep -i -E "(sms|twilio|message)" || echo "No SMS-related logs found"
        fi
        
        echo ""
        echo "ðŸ” SMS Configuration Check:"
        docker exec sms_backend env | grep -E "^(TWILIO_|SMS_)" | sed "s/=.*/=***HIDDEN***/" || echo "No SMS environment variables found"'
        
        # Execute SMS test via SSM
        echo "ðŸš€ Executing SMS functionality test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$SMS_TEST_SCRIPT\"]" \
          --comment "SMS & Twilio Service Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 20
        
        # Get and display results
        echo "ðŸ“Š SMS Service Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… SMS & Twilio services test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "âŒ SMS & Twilio services test failed"
        fi

    - name: Test Scheduled Message Services
      id: scheduler-health
      run: |
        echo "â° Testing Scheduled Message Services..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        # Create scheduler service test script
        SCHEDULER_TEST_SCRIPT='#!/bin/bash
        echo "â° SCHEDULED MESSAGE SERVICE TEST"
        echo "================================"
        echo ""
        
        # Test scheduler service functionality
        echo "Testing scheduler service components..."
        
        if docker exec sms_backend python3 -c "
        import sys
        sys.path.append('\''/app'\'')
        
        try:
            # Test scheduler imports
            from src.scheduler.message_scheduler import MessageScheduler
            from src.scheduler.job_manager import JobManager
            print('\'âœ… Scheduler modules import successfully'\'')
            
            # Test scheduler initialization
            scheduler = MessageScheduler()
            print('\'âœ… Message scheduler initialized'\'')
            
            # Test job manager
            job_manager = JobManager()
            print('\'âœ… Job manager initialized'\'')
            
            # Test scheduler status
            if scheduler.is_running():
                print('\'âœ… Scheduler is running'\'')
            else:
                print('\'âš ï¸ Scheduler is not currently running'\'')
                
        except Exception as e:
            print(f'\'âŒ Scheduler service test failed: {e}'\'')
            import traceback
            traceback.print_exc()
            exit(1)
        " 2>&1; then
          echo "âœ… Scheduler services are functional"
        else
          echo "âŒ Scheduler services failed"
          echo "Checking scheduler-related logs..."
          docker logs --tail 20 sms_backend | grep -i -E "(scheduler|cron|job|task)" || echo "No scheduler-related logs found"
        fi
        
        echo ""
        echo "ðŸ” Background Services Check:"
        echo "Checking if scheduled message processes are running..."
        ps aux | grep -E "(send_scheduled_messages|process_inbound)" || echo "No background message processes found"'
        
        # Execute scheduler test via SSM
        echo "ðŸš€ Executing scheduler functionality test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$SCHEDULER_TEST_SCRIPT\"]" \
          --comment "Scheduler Service Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 20
        
        # Get and display results
        echo "ðŸ“Š Scheduler Service Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Scheduled message services test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "âŒ Scheduled message services test failed"
        fi

    - name: Test Frontend Application
      id: frontend-health
      run: |
        echo "ðŸŽ¨ Testing Frontend Application..."
        
        FRONTEND_URL="${{ steps.infra-details.outputs.frontend_url }}"
        ALB_URL="${{ steps.infra-details.outputs.alb_url }}"
        SUCCESS_COUNT=0
        TOTAL_TESTS=0
        
        # Function to test frontend endpoint
        test_frontend() {
          local url="$1"
          local name="$2"
          
          echo "Testing $name: $url"
          TOTAL_TESTS=$((TOTAL_TESTS + 1))
          
          response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 "$url")
          http_code=$(echo "$response" | grep "HTTPSTATUS:" | cut -d: -f2)
          body=$(echo "$response" | sed 's/HTTPSTATUS:.*//g')
          
          if [ "$http_code" -eq 200 ]; then
            # Check if response contains expected frontend content
            if echo "$body" | grep -q -i -E "(html|react|vue|angular|app|title)" || echo "$body" | grep -q "<!DOCTYPE"; then
              echo "âœ… $name - HTTP $http_code (Valid HTML/App content)"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              echo "âš ï¸ $name - HTTP $http_code (Unexpected content)"
              echo "   Content preview: $(echo "$body" | head -c 100)..."
            fi
          else
            echo "âŒ $name - HTTP $http_code"
            if [ -n "$body" ]; then
              echo "   Error: $(echo "$body" | head -c 100)..."
            fi
          fi
          echo ""
        }
        
        # Test frontend endpoints
        test_frontend "$FRONTEND_URL" "Frontend Root"
        test_frontend "$FRONTEND_URL/login" "Login Page"
        test_frontend "$FRONTEND_URL/dashboard" "Dashboard Page"
        
        # Test static assets (if available)
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if curl -s --max-time 10 "$FRONTEND_URL" | grep -q -i -E "(css|js|script|link)" ; then
          echo "âœ… Frontend static assets detected"
          SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
          echo "âš ï¸ Frontend static assets not clearly detected"
        fi
        
        echo "frontend_success_rate=$SUCCESS_COUNT/$TOTAL_TESTS" >> $GITHUB_OUTPUT
        
        if [ "$SUCCESS_COUNT" -ge 2 ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Frontend health check passed ($SUCCESS_COUNT/$TOTAL_TESTS checks passed)"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "âŒ Frontend health check failed ($SUCCESS_COUNT/$TOTAL_TESTS checks passed)"
        fi

    - name: Test Database Connectivity
      id: database-health
      run: |
        echo "ðŸ—„ï¸ Testing Database Connectivity..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        if [ "$INSTANCE_ID" = "not-found" ]; then
          echo "âŒ No EC2 instance found for database test"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Create database connectivity test script
        DB_TEST_SCRIPT='#!/bin/bash
        echo "ðŸ—„ï¸ DATABASE CONNECTIVITY TEST"
        echo "============================="
        echo ""
        
        # Test database connectivity via backend container
        echo "Testing database connectivity via backend..."
        
        # Check if backend container can connect to database
        if docker exec sms_backend python3 -c "
        import psycopg2
        import os
        try:
            conn = psycopg2.connect(
                host=os.environ['\''DB_HOST'\''],
                port=os.environ['\''DB_PORT'\''],
                database=os.environ['\''DB_NAME'\''],
                user=os.environ['\''DB_USER'\''],
                password=os.environ['\''DB_PASSWORD'\'']
            )
            cursor = conn.cursor()
            cursor.execute('\''SELECT version();'\'')
            version = cursor.fetchone()
            print('\''âœ… Database connection successful'\'')
            print(f'\''   PostgreSQL version: {version[0][:50]}...'\'')
            
            # Test basic queries
            cursor.execute('\''SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = %s;'\'', ('\''public'\'',))
            table_count = cursor.fetchone()[0]
            print(f'\''   Tables in public schema: {table_count}'\'')
            
            cursor.close()
            conn.close()
        except Exception as e:
            print(f'\''âŒ Database connection failed: {e}'\'')
            exit(1)
        " 2>&1; then
          echo "âœ… Database connectivity test passed"
        else
          echo "âŒ Database connectivity test failed"
          echo "Checking container logs for database errors..."
          docker logs --tail 10 sms_backend | grep -i -E "(database|db|postgres|connection)" || echo "No database-related logs found"
        fi
        
        echo ""
        echo "ðŸ” Backend database configuration:"
        docker exec sms_backend env | grep -E "^(DB_|DATABASE_)" | sed "s/PASSWORD=.*/PASSWORD=***HIDDEN***/" || echo "Could not retrieve DB config"'
        
        # Execute database test via SSM
        echo "ðŸš€ Executing database connectivity test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$DB_TEST_SCRIPT\"]" \
          --comment "Database Connectivity Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 15
        
        # Get and display results
        echo "ðŸ“Š Database Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Database connectivity test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "âŒ Database connectivity test failed"
        fi

    - name: Checkout
      uses: actions/checkout@v4

    - name: Validate GitHub Secrets and Variables
      id: validate-config
      run: |
        echo "ðŸ” Validating GitHub Secrets and Variables Configuration..."
        echo "========================================================"
        echo ""
        
        VALIDATION_ERRORS=0
        VALIDATION_WARNINGS=0
        
        # Function to check required secret
        check_secret() {
          local secret_name="$1"
          local secret_value="$2"
          local is_required="${3:-true}"
          
          if [ -z "$secret_value" ] || [ "$secret_value" = "" ]; then
            if [ "$is_required" = "true" ]; then
              echo "âŒ MISSING REQUIRED SECRET: $secret_name"
              VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            else
              echo "âš ï¸ MISSING OPTIONAL SECRET: $secret_name"
              VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
            fi
          else
            # Check if secret looks valid (basic format validation)
            case "$secret_name" in
              *_KEY|*_TOKEN|*_SECRET*) 
                if [ ${#secret_value} -lt 10 ]; then
                  echo "âš ï¸ SECRET TOO SHORT: $secret_name (${#secret_value} characters)"
                  VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                else
                  echo "âœ… SECRET VALID: $secret_name (${#secret_value} characters)"
                fi
                ;;
              *_HOST|*_URL|*_DOMAIN*)
                if echo "$secret_value" | grep -q -E "^[a-zA-Z0-9.-]+$|^https?://"; then
                  echo "âœ… SECRET VALID: $secret_name"
                else
                  echo "âš ï¸ SECRET FORMAT WARNING: $secret_name (may be invalid format)"
                  VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                fi
                ;;
              *)
                echo "âœ… SECRET VALID: $secret_name (configured)"
                ;;
            esac
          fi
        }
        
        # Function to check required variable
        check_variable() {
          local var_name="$1"
          local var_value="$2"
          local is_required="${3:-true}"
          local default_value="${4:-}"
          
          if [ -z "$var_value" ] || [ "$var_value" = "" ]; then
            if [ -n "$default_value" ]; then
              echo "âœ… VARIABLE USING DEFAULT: $var_name (default: $default_value)"
            elif [ "$is_required" = "true" ]; then
              echo "âŒ MISSING REQUIRED VARIABLE: $var_name"
              VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            else
              echo "âš ï¸ MISSING OPTIONAL VARIABLE: $var_name"
              VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
            fi
          else
            echo "âœ… VARIABLE VALID: $var_name ($var_value)"
          fi
        }
        
        echo "ðŸ”‘ REQUIRED SECRETS VALIDATION:"
        echo "==============================="
        check_secret "AWS_ACCESS_KEY_ID" "${{ secrets.AWS_ACCESS_KEY_ID }}"
        check_secret "AWS_SECRET_ACCESS_KEY" "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        check_secret "SSH_PUBLIC_KEY" "${{ secrets.SSH_PUBLIC_KEY }}"
        check_secret "JWT_SECRET_KEY" "${{ secrets.JWT_SECRET_KEY }}"
        check_secret "DB_HOST" "${{ secrets.DB_HOST }}"
        check_secret "DB_USER" "${{ secrets.DB_USER }}"
        check_secret "DB_PASSWORD" "${{ secrets.DB_PASSWORD }}"
        
        echo ""
        echo "ðŸ“± SMS/COMMUNICATION SECRETS:"
        echo "============================="
        check_secret "TWILIO_ACCOUNT_SID" "${{ secrets.TWILIO_ACCOUNT_SID }}"
        check_secret "TWILIO_AUTH_TOKEN" "${{ secrets.TWILIO_AUTH_TOKEN }}"
        check_secret "TWILIO_PHONE_NUMBER" "${{ secrets.TWILIO_PHONE_NUMBER }}"
        
        echo ""
        echo "ðŸ¤– AI/EMAIL SECRETS:"
        echo "==================="
        check_secret "OPENAI_API_KEY" "${{ secrets.OPENAI_API_KEY }}"
        check_secret "SENDGRID_API_KEY" "${{ secrets.SENDGRID_API_KEY }}" false
        check_secret "NGROK_AUTH_TOKEN" "${{ secrets.NGROK_AUTH_TOKEN }}" false
        
        echo ""
        echo "ðŸŒ REQUIRED VARIABLES:"
        echo "====================="
        check_variable "AWS_REGION" "${{ vars.AWS_REGION }}" true "us-east-1"
        check_variable "PROJECT_NAME" "${{ vars.PROJECT_NAME }}" true "sms-seller-connect"
        check_variable "SMS_FRONTEND_DOMAIN" "${{ vars.SMS_FRONTEND_DOMAIN }}" true "sms.typerelations.com"
        check_variable "SMS_API_DOMAIN" "${{ vars.SMS_API_DOMAIN }}" true "api.sms.typerelations.com"
        check_variable "DOMAIN_ZONE_NAME" "${{ vars.DOMAIN_ZONE_NAME }}" true "typerelations.com"
        
        echo ""
        echo "ðŸ”§ INFRASTRUCTURE VARIABLES:"
        echo "============================"
        check_variable "INSTANCE_TYPE" "${{ vars.INSTANCE_TYPE }}" false "t2.micro"
        check_variable "AMI_ID" "${{ vars.AMI_ID }}" false "ami-0c02fb55956c7d316"
        check_variable "KEY_NAME" "${{ vars.KEY_NAME }}" false "sms-seller-connect-key"
        check_variable "VPC_NAME" "${{ vars.VPC_NAME }}" false "Grey-VPC"
        check_variable "S3_BUCKET_NAME" "${{ vars.S3_BUCKET_NAME }}" false "sms-seller-connect-bucket"
        
        echo ""
        echo "ðŸ³ CONTAINER VARIABLES:"
        echo "======================"
        check_variable "ECR_REPO_URL" "${{ vars.ECR_REPO_URL }}" false "522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend"
        check_variable "BACKEND_IMAGE" "${{ vars.BACKEND_IMAGE }}" false
        check_variable "FRONTEND_IMAGE" "${{ vars.FRONTEND_IMAGE }}" false
        check_variable "CONTAINER_TAG" "${{ vars.CONTAINER_TAG }}" false "latest"
        
        echo ""
        echo "ðŸ“Š VALIDATION SUMMARY:"
        echo "====================="
        echo "Validation Errors: $VALIDATION_ERRORS"
        echo "Validation Warnings: $VALIDATION_WARNINGS"
        
        # Set outputs for later steps
        echo "validation_errors=$VALIDATION_ERRORS" >> $GITHUB_OUTPUT
        echo "validation_warnings=$VALIDATION_WARNINGS" >> $GITHUB_OUTPUT
        
        if [ $VALIDATION_ERRORS -gt 0 ]; then
          echo ""
          echo "âŒ VALIDATION FAILED: $VALIDATION_ERRORS critical configuration issues found"
          echo ""
          echo "ðŸ”§ REQUIRED ACTIONS:"
          echo "==================="
          echo "1. Go to your GitHub repository settings"
          echo "2. Navigate to 'Secrets and variables' â†’ 'Actions'"
          echo "3. Add missing secrets to 'Repository secrets'"
          echo "4. Add missing variables to 'Repository variables'"
          echo ""
          echo "âŒ Deployment cannot proceed until all required configuration is set!"
          exit 1
        elif [ $VALIDATION_WARNINGS -gt 0 ]; then
          echo ""
          echo "âš ï¸ VALIDATION PASSED WITH WARNINGS: $VALIDATION_WARNINGS non-critical issues found"
          echo "Deployment will proceed using defaults where applicable."
        else
          echo ""
          echo "âœ… VALIDATION PASSED: All required configuration is properly set"
        fi

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
