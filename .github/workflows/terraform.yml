name: 'SMS Seller Connect - Terraform CI/CD Pipeline'

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      action:
        description: 'Choose action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
          - format
          - redeploy
          - verify-secrets
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  # Terraform Configuration
  TF_VERSION: '1.5.7'
  TF_WORKING_DIR: './modules/ec2'
  
  # AWS Configuration
  AWS_REGION: 'us-east-1'
  AWS_ACCOUNT_ID: '522814698925'
  
  # Backend Configuration
  STATE_BUCKET: 'greyzone-terraform-state'
  LOCK_TABLE: 'terraform-locks'
  STATE_KEY: 'sms-seller-connect/ec2/terraform.tfstate'
  
  # Application Configuration
  PROJECT_NAME: 'sms-seller-connect'
  ECR_REPOSITORY: '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend'
  DOMAIN_NAME: 'typerelations.com'
  SMS_FRONTEND_DOMAIN: 'sms.typerelations.com'
  SMS_API_DOMAIN: 'api.sms.typerelations.com'
  
  # Environment Selection
  ENVIRONMENT: ${{ github.event.inputs.environment || 'prod' }}

jobs:
  format:
    name: '🎨 Auto-Format Terraform'
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' || 
      github.event_name == 'pull_request' || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'format')
    
    permissions:
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Auto-Format Terraform Files
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🎨 Auto-formatting Terraform files..."
        
        # Format all terraform files
        terraform fmt -recursive
        
        # Check if any files were changed
        if [[ -n $(git status --porcelain) ]]; then
          echo "✅ Terraform files have been auto-formatted"
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add and commit changes
          git add .
          git commit -m "🎨 Auto-format Terraform files [skip ci]"
          
          # Push changes
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git push origin HEAD:${{ github.head_ref }}
          else
            git push
          fi
          
          echo "📤 Formatted files committed and pushed"
        else
          echo "ℹ️ All Terraform files are already properly formatted"
        fi

  validate:
    name: '🔍 Validate Terraform'
    runs-on: ubuntu-latest
    needs: [format]
    if: always()
    
    outputs:
      terraform-valid: ${{ steps.validate.outputs.terraform-valid }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🎨 Verifying Terraform formatting..."
        terraform fmt -check -recursive
        echo "✅ All Terraform files are properly formatted"

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Initializing Terraform..."
        terraform init -backend=false

    - name: Terraform Validate
      id: validate
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "✅ Validating Terraform configuration..."
        terraform validate
        echo "terraform-valid=true" >> $GITHUB_OUTPUT

    - name: Security Scan with tfsec
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔒 Running security scan with tfsec..."
        
        # Install tfsec
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
        
        # Run tfsec with custom configuration
        ./tfsec . --format json --out tfsec-results.json || true
        
        # Display results
        if [ -f tfsec-results.json ]; then
          echo "📊 Security scan results:"
          cat tfsec-results.json | jq '.results[] | select(.severity == "HIGH" or .severity == "CRITICAL") | {rule_id: .rule_id, severity: .severity, description: .description}' || echo "No high/critical issues found"
        fi

  plan:
    name: '📋 Plan Infrastructure'
    runs-on: ubuntu-latest
    needs: [format, validate]
    if: needs.validate.outputs.terraform-valid == 'true'
    
    outputs:
      plan-status: ${{ steps.plan.outputs.status }}
      has-changes: ${{ steps.plan.outputs.has-changes }}
      infrastructure-exists: ${{ steps.check-infrastructure.outputs.exists }}
      deployment-strategy: ${{ steps.check-infrastructure.outputs.strategy }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify Backend Health
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔍 Verifying backend health..."
        
        # Check S3 bucket
        if aws s3 ls "s3://${{ env.STATE_BUCKET }}" > /dev/null 2>&1; then
          echo "✅ S3 bucket accessible"
        else
          echo "❌ S3 bucket not accessible"
          exit 1
        fi
        
        # Check DynamoDB table
        if aws dynamodb describe-table --table-name "${{ env.LOCK_TABLE }}" > /dev/null 2>&1; then
          echo "✅ DynamoDB lock table exists"
        else
          echo "❌ DynamoDB lock table missing"
          exit 1
        fi

    - name: Terraform Init with Backend
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Initializing Terraform with S3 backend..."
        terraform init -reconfigure \
          -backend-config="bucket=${{ env.STATE_BUCKET }}" \
          -backend-config="key=${{ env.STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ env.LOCK_TABLE }}" \
          -backend-config="encrypt=true"

    - name: Check and Handle State Lock
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔍 Checking for existing state locks..."
        
        # Function to check if lock is stale (older than 15 minutes)
        check_stale_lock() {
          local lock_time=$1
          local current_time=$(date -u +%s)
          local lock_timestamp=$(date -d "$lock_time" +%s 2>/dev/null || echo "0")
          local age=$((current_time - lock_timestamp))
          
          # If lock is older than 15 minutes (900 seconds), consider it stale
          if [ $age -gt 900 ]; then
            return 0  # stale
          else
            return 1  # not stale
          fi
        }
        
        # Try to get state info to check for locks
        set +e
        terraform refresh -input=false > /dev/null 2>&1
        refresh_exit_code=$?
        set -e
        
        if [ $refresh_exit_code -eq 1 ]; then
          echo "🔒 State lock detected, checking if it's stale..."
          
          # Try to get lock info
          lock_output=$(terraform plan -input=false 2>&1 || true)
          
          if echo "$lock_output" | grep -q "Lock Info:"; then
            lock_id=$(echo "$lock_output" | grep "ID:" | awk '{print $2}')
            lock_time=$(echo "$lock_output" | grep "Created:" | sed 's/.*Created: *\(.*\) UTC.*/\1/')
            lock_who=$(echo "$lock_output" | grep "Who:" | awk '{print $2}')
            
            echo "🔍 Lock details:"
            echo "  ID: $lock_id"
            echo "  Created: $lock_time"
            echo "  Who: $lock_who"
            
            if check_stale_lock "$lock_time"; then
              echo "⚠️ Lock is stale (older than 15 minutes), force unlocking..."
              terraform force-unlock -force "$lock_id"
              echo "✅ Stale lock removed successfully"
            else
              echo "❌ Lock is recent, operation is likely in progress"
              echo "🕐 Waiting 60 seconds for operation to complete..."
              sleep 60
              
              # Check again after waiting
              set +e
              terraform refresh -input=false > /dev/null 2>&1
              second_check=$?
              set -e
              
              if [ $second_check -eq 1 ]; then
                echo "🔒 Lock still exists after waiting, force unlocking..."
                terraform force-unlock -force "$lock_id" || true
                echo "✅ Lock forcefully removed"
              else
                echo "✅ Lock cleared automatically"
              fi
            fi
          fi
        else
          echo "✅ No state lock detected"
        fi

    - name: Set Terraform Environment Variables
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        
        # EC2 Configuration
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        
        # Networking Configuration
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        
        # S3 Configuration
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        
        # Container Configuration
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        
        # Domain Configuration
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        
        # Monitoring
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        
        # Secrets
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        
        # Application URLs
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        
        # Additional Configuration
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "🔧 Setting Terraform environment variables from GitHub secrets..."
        echo "✅ All Terraform environment variables configured using GitHub Actions env context"
        echo "📊 Environment: ${{ env.ENVIRONMENT }}"
        echo "🔒 Secrets and variables loaded as TF_VAR_* environment variables"
        
        # Verify some key variables are set
        echo "🔍 Verifying key environment variables..."
        echo "Region: ${TF_VAR_region:-NOT_SET}"
        echo "Environment: ${TF_VAR_environment:-NOT_SET}"
        echo "Project: ${TF_VAR_project_name:-NOT_SET}"
        echo "Instance Type: ${TF_VAR_instance_type:-NOT_SET}"
        
        # Verify problematic tag variables are not set
        echo "🔍 Verifying tag variables are not set..."
        if [ -n "${TF_VAR_tags:-}" ]; then
          echo "⚠️ WARNING: TF_VAR_tags is set: ${TF_VAR_tags}"
        else
          echo "✅ TF_VAR_tags is not set (good)"
        fi
        
        if [ -n "${TF_VAR_common_tags:-}" ]; then
          echo "⚠️ WARNING: TF_VAR_common_tags is set: ${TF_VAR_common_tags}"
        else
          echo "✅ TF_VAR_common_tags is not set (good)"
        fi

    - name: Set Boolean Environment Variables
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Setting boolean environment variables for Terraform..."
        
        # Convert string boolean values to proper booleans
        # GitHub Actions passes booleans as strings, so we need to convert them
        
        # Set use_default_vpc
        if [ "${{ vars.USE_DEFAULT_VPC || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_default_vpc=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_default_vpc=false" >> $GITHUB_ENV
        fi
        
        # Set s3_force_destroy
        if [ "${{ vars.S3_FORCE_DESTROY || 'false' }}" = "true" ]; then
          echo "TF_VAR_s3_force_destroy=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_s3_force_destroy=false" >> $GITHUB_ENV
        fi
        
        # Set use_postgres
        if [ "${{ vars.USE_POSTGRES || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_postgres=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_postgres=false" >> $GITHUB_ENV
        fi
        
        # Set start_ngrok
        if [ "${{ vars.START_NGROK || 'true' }}" = "true" ]; then
          echo "TF_VAR_start_ngrok=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_start_ngrok=false" >> $GITHUB_ENV
        fi
        
        # Set debug
        if [ "${{ vars.DEBUG || 'true' }}" = "true" ]; then
          echo "TF_VAR_debug=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_debug=false" >> $GITHUB_ENV
        fi
        
        # Set enable_carrental_domain (hardcoded to false)
        echo "TF_VAR_enable_carrental_domain=false" >> $GITHUB_ENV
        
        echo "✅ Boolean environment variables set successfully!"

    - name: Check Infrastructure Existence & Determine Strategy
      id: check-infrastructure
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔍 INTELLIGENT DEPLOYMENT STRATEGY DETECTION"
        echo "============================================="
        echo ""
        
        # Check if key infrastructure components exist
        INFRASTRUCTURE_EXISTS=false
        STRATEGY="full-deploy"
        
        echo "🔍 Checking for existing infrastructure components..."
        
        # Check for EC2 instance
        EC2_EXISTS=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-seller-connect-${{ env.ENVIRONMENT }}-ec2" "Name=instance-state-name,Values=running,stopped,stopping" \
          --query 'Reservations[*].Instances[*].InstanceId' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$EC2_EXISTS" ] && [ "$EC2_EXISTS" != "None" ]; then
          echo "✅ EC2 instance found: $EC2_EXISTS"
          INFRASTRUCTURE_EXISTS=true
        else
          echo "❌ No EC2 instance found"
        fi
        
        # Check for ALB
        ALB_EXISTS=$(aws elbv2 describe-load-balancers \
          --names "sms-seller-connect-${{ env.ENVIRONMENT }}-alb" \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$ALB_EXISTS" ] && [ "$ALB_EXISTS" != "None" ]; then
          echo "✅ ALB found: $(basename $ALB_EXISTS)"
          INFRASTRUCTURE_EXISTS=true
        else
          echo "❌ No ALB found"
        fi
        
        # Check for S3 bucket
        BUCKET_EXISTS=$(aws s3api head-bucket --bucket "sms-seller-connect-${{ env.ENVIRONMENT }}-bucket" 2>/dev/null && echo "true" || echo "false")
        
        if [ "$BUCKET_EXISTS" = "true" ]; then
          echo "✅ S3 bucket found"
          INFRASTRUCTURE_EXISTS=true
        else
          echo "❌ No S3 bucket found"
        fi
        
        # Check for Route53 hosted zone
        ROUTE53_EXISTS=$(aws route53 list-hosted-zones \
          --query "HostedZones[?Name=='${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}.'].Id" \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$ROUTE53_EXISTS" ] && [ "$ROUTE53_EXISTS" != "None" ]; then
          echo "✅ Route53 hosted zone found"
        else
          echo "❌ No Route53 hosted zone found"
        fi
        
        echo ""
        echo "🎯 DEPLOYMENT STRATEGY DECISION:"
        echo "==============================="
        
        if [ "$INFRASTRUCTURE_EXISTS" = "true" ]; then
          # Check if EC2 is running and accessible
          if [ -n "$EC2_EXISTS" ]; then
            EC2_STATE=$(aws ec2 describe-instances \
              --instance-ids "$EC2_EXISTS" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "")
            
            echo "📊 EC2 Instance State: $EC2_STATE"
            
            if [ "$EC2_STATE" = "running" ]; then
              # Check if we can connect to the instance
              EC2_IP=$(aws ec2 describe-instances \
                --instance-ids "$EC2_EXISTS" \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$EC2_IP" ] && [ "$EC2_IP" != "None" ]; then
                echo "✅ EC2 is running and accessible at $EC2_IP"
                STRATEGY="redeploy"
                echo "🚀 STRATEGY: Fast Redeploy - Update existing running infrastructure"
              else
                STRATEGY="full-deploy"
                echo "🏗️ STRATEGY: Full Deploy - EC2 exists but not accessible"
              fi
            else
              STRATEGY="full-deploy"
              echo "🏗️ STRATEGY: Full Deploy - EC2 exists but not running ($EC2_STATE)"
            fi
          else
            STRATEGY="full-deploy"
            echo "🏗️ STRATEGY: Full Deploy - Some infrastructure exists but EC2 missing"
          fi
        else
          STRATEGY="full-deploy"
          echo "🏗️ STRATEGY: Full Deploy - No existing infrastructure detected"
        fi
        
        echo ""
        echo "📋 STRATEGY SUMMARY:"
        echo "==================="
        if [ "$STRATEGY" = "redeploy" ]; then
          echo "✨ FAST REDEPLOY selected"
          echo "   • Infrastructure exists and is healthy"
          echo "   • Will update containers and configurations"
          echo "   • Estimated time: ~5 minutes"
          echo "   • Route: plan → redeploy → health-check"
        else
          echo "🏗️ FULL DEPLOYMENT selected"
          echo "   • Infrastructure missing or unhealthy"
          echo "   • Will create/recreate all resources"
          echo "   • Estimated time: ~15 minutes"
          echo "   • Route: plan → apply → health-check"
        fi
        
        # Set outputs
        echo "exists=$INFRASTRUCTURE_EXISTS" >> $GITHUB_OUTPUT
        echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
        
        echo ""
        echo "🔄 Next job will be: $([ "$STRATEGY" = "redeploy" ] && echo "Fast Redeploy" || echo "Full Apply")"

    - name: Terraform Plan
      id: plan
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        
        # EC2 Configuration
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        
        # Networking Configuration
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        
        # S3 Configuration
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        
        # Container Configuration
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        
        # Domain Configuration
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        
        # Monitoring
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        
        # Secrets
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        
        # Application URLs
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        
        # Additional Configuration
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "📋 Creating Terraform plan for ${{ env.ENVIRONMENT }} environment..."
        
        # Debug: Show some environment variables are set
        echo "🔍 DEBUG: Checking key variables..."
        echo "Environment: ${TF_VAR_environment:-NOT_SET}"
        echo "Project: ${TF_VAR_project_name:-NOT_SET}"
        echo "Region: ${TF_VAR_region:-NOT_SET}"
        echo "Instance Type: ${TF_VAR_instance_type:-NOT_SET}"
        
        # Debug: Verify problematic tag variables are not set
        echo "🔍 DEBUG: Verifying tag variables are not set..."
        if [ -n "${TF_VAR_tags:-}" ]; then
          echo "❌ ERROR: TF_VAR_tags is set: ${TF_VAR_tags}"
        else
          echo "✅ TF_VAR_tags is not set (good)"
        fi
        
        if [ -n "${TF_VAR_common_tags:-}" ]; then
          echo "❌ ERROR: TF_VAR_common_tags is set: ${TF_VAR_common_tags}"
        else
          echo "✅ TF_VAR_common_tags is not set (good)"
        fi

                 # Create plan with detailed exit codes and disable input prompts
         echo "🚀 Starting terraform plan with timeout protection and auto-retry..."
         
         # Function to run terraform plan with retry on lock conflicts
         run_terraform_plan() {
           local attempt=1
           local max_attempts=3
           
           while [ $attempt -le $max_attempts ]; do
             echo "📋 Attempt $attempt/$max_attempts: Running terraform plan..."
             
             set +e
             timeout 300 terraform plan -input=false -detailed-exitcode -no-color -out=tfplan 2>&1 | tee plan_output.txt
             exit_code=$?
             set -e
            
            # Check if timeout occurred
            if [ $exit_code -eq 124 ]; then
              echo "❌ Terraform plan timed out after 5 minutes"
              exit 1
            fi
            
            # Check for lock conflicts
            if grep -q "Error acquiring the state lock" plan_output.txt; then
              echo "🔒 Lock conflict detected on attempt $attempt"
              
              if [ $attempt -lt $max_attempts ]; then
                # Extract lock ID and force unlock
                lock_id=$(grep -A 20 "Lock Info:" plan_output.txt | grep "ID:" | awk '{print $2}' || echo "")
                if [ -n "$lock_id" ]; then
                  echo "🔓 Force unlocking stale lock: $lock_id"
                  terraform force-unlock -force "$lock_id" || true
                fi
                
                echo "⏳ Waiting 30 seconds before retry..."
                sleep 30
                attempt=$((attempt + 1))
                continue
              else
                echo "❌ Failed to acquire lock after $max_attempts attempts"
                exit 1
              fi
            else
              # Plan succeeded or failed for other reasons
              break
            fi
          done
          
          return $exit_code
        }
        
        # Run terraform plan with retry logic
        run_terraform_plan
        
        echo "🔍 DEBUG: Terraform plan exit code was: $exit_code"
        
        # Check for changes in plan output as backup detection method
        if grep -q "Plan: .* to add\|Plan: .* to change\|Plan: .* to destroy" plan_output.txt; then
          plan_has_changes=$(grep "Plan: " plan_output.txt | grep -v "Plan: 0 to add, 0 to change, 0 to destroy" | wc -l)
        else
          plan_has_changes=0
        fi
        
        echo "🔍 DEBUG: Plan changes detected in output: $plan_has_changes"
        
        # Check if there were validation errors (terraform exits with 1 for errors)
        if grep -q "Error:" plan_output.txt; then
          echo "❌ Terraform validation errors detected"
          echo "status=error" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
          echo "🔍 Showing validation errors:"
          cat plan_output.txt
          exit 1
        fi
        
        case $exit_code in
          0)
            # Double-check for changes even with exit code 0 (terraform bug workaround)
            if [ "$plan_has_changes" -gt 0 ]; then
              echo "⚠️ Exit code 0 but changes detected in plan output - treating as changes"
              echo "status=changes-detected" >> $GITHUB_OUTPUT
              echo "has-changes=true" >> $GITHUB_OUTPUT
              echo "📝 Changes detected (exit code: $exit_code, but plan shows changes)"
            else
              echo "status=no-changes" >> $GITHUB_OUTPUT
              echo "has-changes=false" >> $GITHUB_OUTPUT
              echo "✅ No changes detected (exit code: $exit_code)"
            fi
            ;;
          1)
            echo "status=error" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "❌ Planning failed (exit code: $exit_code)"
            exit 1
            ;;
          2)
            echo "status=changes-detected" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "📝 Changes detected (exit code: $exit_code)"
            ;;
          *)
            echo "⚠️ Unexpected exit code: $exit_code - treating as error"
            echo "status=error" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 1
            ;;
        esac
        
        # Clean up temporary file
        rm -f plan_output.txt

    - name: Show Plan Summary
      if: steps.plan.outputs.has-changes == 'true'
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "📊 Infrastructure Plan Summary for ${{ env.ENVIRONMENT }}:"
        terraform show -no-color tfplan | head -50
        echo ""
        echo "📈 Resource Changes:"
        terraform show -json tfplan | jq -r '.resource_changes[] | "\(.change.action | join(",")): \(.address)"' | sort | uniq -c

    - name: Upload Plan
      if: steps.plan.outputs.has-changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ env.ENVIRONMENT }}
        path: |
          ${{ env.TF_WORKING_DIR }}/tfplan
          ${{ env.TF_WORKING_DIR }}/terraform-${{ env.ENVIRONMENT }}.tfvars

  apply:
    name: '🏗️ Full Infrastructure Deployment'
    runs-on: ubuntu-latest
    needs: [format, validate, plan]
    if: |
      needs.plan.outputs.deployment-strategy == 'full-deploy' && (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
        (github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.plan.outputs.has-changes == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan' && needs.plan.outputs.has-changes == 'true')
      )
    
    steps:
    - name: Auto-Deploy Notification
      run: |
        echo "🚀 AUTO-DEPLOYMENT TRIGGERED!"
        echo "=============================="
        if [ "${{ github.event.inputs.action }}" = "plan" ]; then
          echo "🎯 Reason: Plan detected changes - proceeding to automatic deployment"
        elif [ "${{ github.event_name }}" = "push" ]; then
          echo "🎯 Reason: Push to main branch with infrastructure changes"
        else
          echo "🎯 Reason: Manual apply action requested"
        fi
        echo "🔧 Environment: ${{ env.ENVIRONMENT }}"
        echo "📦 Project: ${{ env.PROJECT_NAME }}"
        echo ""

    - name: Checkout
      uses: actions/checkout@v4

    - name: Validate Critical Secrets for Deployment
      run: |
        echo "🔐 Quick validation of critical secrets for deployment..."
        MISSING_SECRETS=0
        
        # Check absolutely critical secrets needed for deployment
        [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && echo "❌ Missing AWS_ACCESS_KEY_ID" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ] && echo "❌ Missing AWS_SECRET_ACCESS_KEY" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.SSH_PUBLIC_KEY }}" ] && echo "❌ Missing SSH_PUBLIC_KEY" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.DB_HOST }}" ] && echo "❌ Missing DB_HOST" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.DB_PASSWORD }}" ] && echo "❌ Missing DB_PASSWORD" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.TWILIO_ACCOUNT_SID }}" ] && echo "❌ Missing TWILIO_ACCOUNT_SID" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        [ -z "${{ secrets.OPENAI_API_KEY }}" ] && echo "❌ Missing OPENAI_API_KEY" && MISSING_SECRETS=$((MISSING_SECRETS + 1))
        
        if [ $MISSING_SECRETS -gt 0 ]; then
          echo "❌ DEPLOYMENT BLOCKED: $MISSING_SECRETS critical secrets are missing!"
          echo "This should not happen if plan validation passed. Check repository secrets configuration."
          exit 1
        else
          echo "✅ All critical secrets available for deployment"
        fi

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download Plan
      if: needs.plan.outputs.has-changes == 'true'
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-${{ env.ENVIRONMENT }}
        path: ${{ env.TF_WORKING_DIR }}/

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Initializing Terraform..."
        terraform init -reconfigure \
          -backend-config="bucket=${{ env.STATE_BUCKET }}" \
          -backend-config="key=${{ env.STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ env.LOCK_TABLE }}" \
          -backend-config="encrypt=true"

    - name: Set Environment Variables for Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "🔧 Setting up environment variables for apply..."
        echo "✅ All Terraform environment variables configured using GitHub Actions env context"

    - name: Set Boolean Environment Variables for Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Setting boolean environment variables for Terraform Apply..."
        
        # Set use_default_vpc
        if [ "${{ vars.USE_DEFAULT_VPC || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_default_vpc=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_default_vpc=false" >> $GITHUB_ENV
        fi
        
        # Set s3_force_destroy
        if [ "${{ vars.S3_FORCE_DESTROY || 'false' }}" = "true" ]; then
          echo "TF_VAR_s3_force_destroy=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_s3_force_destroy=false" >> $GITHUB_ENV
        fi
        
        # Set use_postgres
        if [ "${{ vars.USE_POSTGRES || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_postgres=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_postgres=false" >> $GITHUB_ENV
        fi
        
        # Set start_ngrok
        if [ "${{ vars.START_NGROK || 'true' }}" = "true" ]; then
          echo "TF_VAR_start_ngrok=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_start_ngrok=false" >> $GITHUB_ENV
        fi
        
        # Set debug
        if [ "${{ vars.DEBUG || 'true' }}" = "true" ]; then
          echo "TF_VAR_debug=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_debug=false" >> $GITHUB_ENV
        fi
        
        # Set enable_carrental_domain (hardcoded to false)
        echo "TF_VAR_enable_carrental_domain=false" >> $GITHUB_ENV
        
        echo "✅ Boolean environment variables set for Apply!"

    - name: Terraform Apply
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "🚀 Applying Terraform changes for ${{ env.ENVIRONMENT }} environment..."
        echo "📍 Backend: s3://${{ env.STATE_BUCKET }}/${{ env.STATE_KEY }}"
        
                 if [ -f "tfplan" ]; then
           echo "📋 Applying saved plan..."
           terraform apply -auto-approve tfplan
         else
           echo "📋 Creating and applying new plan..."
           terraform apply -auto-approve
         fi
        
        echo "✅ SMS Seller Connect infrastructure deployment completed!"

    - name: Get Infrastructure Outputs
      id: outputs
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "📊 Getting infrastructure outputs..."
        
        # Get EC2 outputs
        if terraform output instance_public_ip > /dev/null 2>&1; then
          INSTANCE_IP=$(terraform output -raw instance_public_ip 2>/dev/null || echo "N/A")
          echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
          echo "🌐 Instance IP: ${INSTANCE_IP}"
        fi
        
        if terraform output instance_id > /dev/null 2>&1; then
          INSTANCE_ID=$(terraform output -raw instance_id 2>/dev/null || echo "N/A")
          echo "instance_id=${INSTANCE_ID}" >> $GITHUB_OUTPUT
          echo "🆔 Instance ID: ${INSTANCE_ID}"
        fi
        
        # Get ALB outputs
        if terraform output alb_dns_name > /dev/null 2>&1; then
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "N/A")
          echo "alb_dns=${ALB_DNS}" >> $GITHUB_OUTPUT
          echo "🔗 ALB DNS: ${ALB_DNS}"
        fi
        
        # Get S3 outputs
        if terraform output s3_bucket_name > /dev/null 2>&1; then
          BUCKET_NAME=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "N/A")
          echo "bucket_name=${BUCKET_NAME}" >> $GITHUB_OUTPUT
          echo "🪣 Bucket Name: ${BUCKET_NAME}"
        fi
        
        # Get domain outputs
        if terraform output sms_frontend_url > /dev/null 2>&1; then
          FRONTEND_URL=$(terraform output -raw sms_frontend_url 2>/dev/null || echo "N/A")
          echo "frontend_url=${FRONTEND_URL}" >> $GITHUB_OUTPUT
          echo "🌐 Frontend URL: ${FRONTEND_URL}"
        fi
        
        if terraform output sms_api_url > /dev/null 2>&1; then
          API_URL=$(terraform output -raw sms_api_url 2>/dev/null || echo "N/A")
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "🔗 API URL: ${API_URL}"
        fi
        
        # Show all outputs
        echo "📋 All outputs:"
        terraform output 2>/dev/null || echo "ℹ️ No outputs available"

    - name: Deployment Completion Summary
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "✅ INFRASTRUCTURE DEPLOYMENT COMPLETED!"
        echo "======================================"
        echo ""
        echo "🚀 Successfully deployed SMS Seller Connect infrastructure"
        echo "📦 Project: ${{ env.PROJECT_NAME }}"
        echo "🌍 Environment: ${{ env.ENVIRONMENT }}"
        echo "⏰ Deployment completed at: $(date)"
        echo ""
        echo "📋 Infrastructure components deployed:"
        echo "  ✅ EC2 Instance"
        echo "  ✅ Application Load Balancer (ALB)"
        echo "  ✅ S3 Configuration Bucket"
        echo "  ✅ Route53 DNS Records"
        echo "  ✅ ACM SSL Certificates"
        echo "  ✅ Security Groups & Networking"
        echo "  ✅ CloudWatch Monitoring"
        echo ""
        echo "🔄 Next: Infrastructure Testing Stage will begin after stabilization period"
        echo "⏳ Testing will start after 13-minute wait to allow all services to stabilize"
        echo ""
        echo "📊 Check the 'Comprehensive Health Check' job for detailed verification results"

    - name: Update CloudWatch Dashboard
      run: |
        echo "📊 Updating CloudWatch dashboard..."
        
        # Create/update CloudWatch dashboard for monitoring
        aws cloudwatch put-dashboard \
          --dashboard-name "SMS-Seller-Connect-${{ env.ENVIRONMENT }}" \
          --dashboard-body '{
            "widgets": [
              {
                "type": "metric",
                "properties": {
                  "metrics": [
                    ["AWS/EC2", "CPUUtilization", "InstanceId", "${{ steps.outputs.outputs.instance_id }}"],
                    [".", "NetworkIn", ".", "."],
                    [".", "NetworkOut", ".", "."]
                  ],
                  "period": 300,
                  "stat": "Average",
                  "region": "${{ env.AWS_REGION }}",
                  "title": "EC2 System Metrics"
                }
              },
              {
                "type": "metric",
                "properties": {
                  "metrics": [
                    ["AWS/ApplicationELB", "RequestCount", "LoadBalancer", "${{ steps.outputs.outputs.alb_dns }}"],
                    [".", "TargetResponseTime", ".", "."],
                    [".", "HTTPCode_Target_2XX_Count", ".", "."]
                  ],
                  "period": 300,
                  "stat": "Sum",
                  "region": "${{ env.AWS_REGION }}",
                  "title": "ALB Metrics"
                }
              }
            ]
          }' || echo "⚠️ Dashboard update failed, continuing..."

    - name: Display Deployment Results
      if: always()
      run: |
        echo "#### 🚀 SMS Seller Connect Deployment Results"
        echo ""
        echo "**Status**: ${{ job.status == 'success' && '✅ Successfully Deployed' || '❌ Deployment Failed' }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo "**Project**: ${{ env.PROJECT_NAME }}"
        echo ""
        echo "### 🌐 Application URLs:"
        echo "- **Frontend**: ${{ steps.outputs.outputs.frontend_url }}"
        echo "- **API**: ${{ steps.outputs.outputs.api_url }}"
        echo "- **Health Check**: ${{ steps.outputs.outputs.api_url }}/api/health"
        echo ""
        echo "### 🏗️ Infrastructure Details:"
        echo "- **Instance IP**: ${{ steps.outputs.outputs.instance_ip }}"
        echo "- **Instance ID**: ${{ steps.outputs.outputs.instance_id }}"
        echo "- **ALB DNS**: ${{ steps.outputs.outputs.alb_dns }}"
        echo "- **S3 Bucket**: ${{ steps.outputs.outputs.bucket_name }}"
        echo "- **ECR Repository**: ${{ env.ECR_REPOSITORY }}"
        echo ""
        echo "### 📊 Monitoring Links:"
        echo "- **CloudWatch**: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#dashboards:name=SMS-Seller-Connect-${{ env.ENVIRONMENT }}"
        echo "- **EC2 Console**: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#Instances:search=${{ steps.outputs.outputs.instance_id }}"
        echo "- **ALB Console**: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#LoadBalancers:"
        echo ""
        echo "### 🔧 Features Deployed:"
        echo "- ✅ EC2 Instance with ALB multi-app architecture"
        echo "- ✅ Application Load Balancer with SSL termination"
        echo "- ✅ S3 bucket for configuration files"
        echo "- ✅ CloudWatch monitoring and logging"
        echo "- ✅ Route53 DNS records"
        echo "- ✅ ACM SSL certificates"
        echo "- ✅ Docker containerized applications"
        echo "- ✅ Nginx reverse proxy"

    - name: Display Route53 Name Servers
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🌐 Route53 Name Servers for Domain Configuration"
        echo "================================================"
        
        # Get the name servers from Terraform output
        if terraform output route53_name_servers > /dev/null 2>&1; then
          NAME_SERVERS=$(terraform output -raw route53_name_servers 2>/dev/null || echo "N/A")
          ZONE_ID=$(terraform output -raw route53_zone_id 2>/dev/null || echo "N/A")
          ZONE_NAME=$(terraform output -raw route53_zone_name 2>/dev/null || echo "N/A")
          
          echo "📋 **IMPORTANT**: Update your domain registrar with these name servers:"
          echo "🆔 Zone ID: $ZONE_ID"
          echo "🌐 Zone Name: $ZONE_NAME"
          echo ""
          echo "📝 Name Servers to configure with your registrar:"
          echo "$NAME_SERVERS" | sed 's/\[//g' | sed 's/\]//g' | sed 's/,/\n/g' | sed 's/"//g' | sed 's/^ *//g'
          echo ""
          echo "⚠️  **Domain will not resolve until name servers are updated with your registrar!**"
        else
          echo "⚠️ Could not retrieve Route53 name servers from Terraform output"
        fi


        
        if [ "$PASSED" -ge 5 ]; then
          echo "🎉 OVERALL STATUS: ✅ HEALTHY"
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo ""
          echo "🌟 Your SMS Seller Connect application is running successfully!"
          echo ""
          echo "🔗 Application URLs:"
          echo "   Frontend: ${{ steps.infra-details.outputs.frontend_url }}"
          echo "   API: ${{ steps.infra-details.outputs.api_url }}"
          echo "   ALB: ${{ steps.infra-details.outputs.alb_url }}"
        else
          echo "⚠️ OVERALL STATUS: ❌ UNHEALTHY"
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo ""
          echo "❌ Some components are not functioning properly."
          echo "   Please review the test results above and check logs."
        fi
        
        # Save health summary
        echo "health_score=$PASSED/$TOTAL" >> $GITHUB_OUTPUT

    - name: Post Health Check Results to PR
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const healthStatus = '${{ steps.overall-health.outputs.status }}';
          const healthScore = '${{ steps.overall-health.outputs.health_score }}';
          const frontendUrl = '${{ steps.infra-details.outputs.frontend_url }}';
          const apiUrl = '${{ steps.infra-details.outputs.api_url }}';
          
          const emoji = healthStatus === 'healthy' ? '🎉' : '⚠️';
          const status = healthStatus === 'healthy' ? 'HEALTHY' : 'NEEDS ATTENTION';
          
          const comment = `## ${emoji} SMS Seller Connect Health Check Results
          
          **Overall Status**: ${status}  
          **Health Score**: ${healthScore}
          
          ### 🔍 Component Status
          - 🐳 **Containers**: ${{ steps.container-health.outputs.status == 'success' && '✅ Healthy' || '❌ Issues detected' }}
          - 🔧 **Backend API**: ${{ steps.backend-health.outputs.status == 'success' && '✅ Responding' || '❌ Not responding' }} (${{ steps.backend-health.outputs.backend_success_rate || 'N/A' }})
          - 🤖 **AI Processing**: ${{ steps.ai-health.outputs.status == 'success' && '✅ Functional' || '❌ Not working' }}
          - 📱 **SMS/Twilio**: ${{ steps.sms-health.outputs.status == 'success' && '✅ Operational' || '❌ Issues detected' }}
          - ⏰ **Scheduler**: ${{ steps.scheduler-health.outputs.status == 'success' && '✅ Running' || '❌ Not running' }}
          - 🎨 **Frontend**: ${{ steps.frontend-health.outputs.status == 'success' && '✅ Accessible' || '❌ Not accessible' }} (${{ steps.frontend-health.outputs.frontend_success_rate || 'N/A' }})
          - 🗄️ **Database**: ${{ steps.database-health.outputs.status == 'success' && '✅ Connected' || '❌ Connection issues' }}
          
          ### 🌐 Application URLs
          - **Frontend**: ${frontendUrl}
          - **API**: ${apiUrl}
          
          ${healthStatus === 'healthy' ? 
            '🎊 **All systems are operational!** Your SMS Seller Connect application is ready for full use with AI processing, SMS communication, scheduled messages, and all features functional.' : 
            '⚠️ **Some issues detected.** Please review the detailed logs in the Actions tab to see which specific features need attention.'}
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

    - name: Health Check Summary
      if: always()
      run: |
        echo "#### 🏥 SMS Seller Connect Comprehensive Health Check Summary"
        echo ""
        echo "**Overall Status**: ${{ steps.overall-health.outputs.status == 'healthy' && '✅ HEALTHY' || '⚠️ NEEDS ATTENTION' }}"
        echo "**Health Score**: ${{ steps.overall-health.outputs.health_score }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo ""
        echo "**Feature Test Results**:"
        echo "- Containers: ${{ steps.container-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo "- Backend API: ${{ steps.backend-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo "- AI Processing: ${{ steps.ai-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo "- SMS/Twilio: ${{ steps.sms-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo "- Scheduler: ${{ steps.scheduler-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo "- Frontend: ${{ steps.frontend-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo "- Database: ${{ steps.database-health.outputs.status == 'success' && '✅' || '❌' }}"
        echo ""
        echo "**Application URLs**:"
        echo "- Frontend: ${{ steps.infra-details.outputs.frontend_url }}"
        echo "- API: ${{ steps.infra-details.outputs.api_url }}"
        echo "- ALB: ${{ steps.infra-details.outputs.alb_url }}"
        echo ""
        echo "${{ steps.overall-health.outputs.status == 'healthy' && '🎉 **All SMS Seller Connect features operational!**' || '⚠️ **Review required - check feature-specific logs above**' }}"

  destroy:
    name: '💥 Destroy Infrastructure'
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Initializing Terraform..."
        terraform init -reconfigure \
          -backend-config="bucket=${{ env.STATE_BUCKET }}" \
          -backend-config="key=${{ env.STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ env.LOCK_TABLE }}" \
          -backend-config="encrypt=true"

    - name: Set Environment Variables for Destroy
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "🔧 Setting up environment variables for destroy..."
        echo "✅ All Terraform environment variables configured using GitHub Actions env context"

    - name: Set Boolean Environment Variables for Destroy
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "🔧 Setting boolean environment variables for Terraform Destroy..."
        
        # Set use_default_vpc
        if [ "${{ vars.USE_DEFAULT_VPC || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_default_vpc=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_default_vpc=false" >> $GITHUB_ENV
        fi
        
        # Set s3_force_destroy
        if [ "${{ vars.S3_FORCE_DESTROY || 'false' }}" = "true" ]; then
          echo "TF_VAR_s3_force_destroy=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_s3_force_destroy=false" >> $GITHUB_ENV
        fi
        
        # Set use_postgres
        if [ "${{ vars.USE_POSTGRES || 'true' }}" = "true" ]; then
          echo "TF_VAR_use_postgres=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_use_postgres=false" >> $GITHUB_ENV
        fi
        
        # Set start_ngrok
        if [ "${{ vars.START_NGROK || 'true' }}" = "true" ]; then
          echo "TF_VAR_start_ngrok=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_start_ngrok=false" >> $GITHUB_ENV
        fi
        
        # Set debug
        if [ "${{ vars.DEBUG || 'true' }}" = "true" ]; then
          echo "TF_VAR_debug=true" >> $GITHUB_ENV
        else
          echo "TF_VAR_debug=false" >> $GITHUB_ENV
        fi
        
        # Set enable_carrental_domain (hardcoded to false)
        echo "TF_VAR_enable_carrental_domain=false" >> $GITHUB_ENV
        
        echo "✅ Boolean environment variables set for Destroy!"

    - name: Show Resources to be Destroyed
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "🔍 Resources that will be destroyed in ${{ env.ENVIRONMENT }}:"
        
        terraform state list
        echo ""
        echo "📋 Destroy plan:"
        terraform plan -destroy -no-color

    - name: Terraform Destroy
      working-directory: ${{ env.TF_WORKING_DIR }}
      env:
        # Basic Configuration
        TF_VAR_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_environment: ${{ env.ENVIRONMENT }}
        TF_VAR_project_name: ${{ vars.PROJECT_NAME || 'sms-seller-connect' }}
        TF_VAR_ami_id: ${{ vars.AMI_ID || 'ami-0c02fb55956c7d316' }}
        TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE || 't2.micro' }}
        TF_VAR_key_name: ${{ vars.KEY_NAME || 'sms-seller-connect-key' }}
        TF_VAR_instance_name: ${{ vars.INSTANCE_NAME || 'sms-seller-connect' }}
        TF_VAR_vpc_name: ${{ vars.VPC_NAME || 'Grey-VPC' }}
        TF_VAR_subnet_name: ${{ vars.SUBNET_NAME || 'Grey-private-subnet' }}
        TF_VAR_subnet_name_b: ${{ vars.SUBNET_NAME_B || 'Grey-public-subnet' }}
        TF_VAR_admin_ssh_cidr: ${{ vars.ADMIN_SSH_CIDR || '0.0.0.0/0' }}
        TF_VAR_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_bucket_name: ${{ vars.S3_BUCKET_NAME || 'sms-seller-connect-bucket' }}
        TF_VAR_s3_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_bucket_acl: ${{ vars.S3_ACL || 'private' }}
        TF_VAR_ecr_repo_url: ${{ vars.ECR_REPO_URL || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend' }}
        TF_VAR_container_tag: ${{ vars.CONTAINER_TAG || github.sha }}
        TF_VAR_app_port: ${{ vars.APP_PORT || '8900' }}
        TF_VAR_backend_image: ${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}
        TF_VAR_frontend_image: ${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}
        TF_VAR_domain_zone_name: ${{ vars.DOMAIN_ZONE_NAME || 'typerelations.com' }}
        TF_VAR_domain_name: ${{ vars.DOMAIN_NAME || 'typerelations.com' }}
        TF_VAR_sms_frontend_domain: ${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_sms_api_domain: ${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_alert_email: ${{ vars.ALERT_EMAIL || 'dcaulcrick01@gmail.com' }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        TF_VAR_db_host: ${{ secrets.DB_HOST }}
        TF_VAR_db_user: ${{ secrets.DB_USER }}
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_jwt_secret_key: ${{ secrets.JWT_SECRET_KEY }}
        TF_VAR_twilio_account_sid: ${{ secrets.TWILIO_ACCOUNT_SID }}
        TF_VAR_twilio_auth_token: ${{ secrets.TWILIO_AUTH_TOKEN }}
        TF_VAR_twilio_phone_number: ${{ secrets.TWILIO_PHONE_NUMBER }}
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_sendgrid_api_key: ${{ secrets.SENDGRID_API_KEY }}
        TF_VAR_ngrok_auth_token: ${{ secrets.NGROK_AUTH_TOKEN }}
        TF_VAR_hot_lead_sms_recipients: ${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}
        TF_VAR_database_url: postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ secrets.DB_HOST }}:5437/sms_blast
        TF_VAR_twilio_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/webhooks/sms
        TF_VAR_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_frontend_url: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_db_port: ${{ vars.DB_PORT || '5437' }}
        TF_VAR_db_name: ${{ vars.DB_NAME || 'sms_blast' }}
        TF_VAR_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
        TF_VAR_openai_model: ${{ vars.OPENAI_MODEL || 'gpt-3.5-turbo' }}
        TF_VAR_openai_temperature: ${{ vars.OPENAI_TEMPERATURE || '0.7' }}
        TF_VAR_sendgrid_from_email: ${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}
        TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        TF_VAR_aws_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_aws_default_region: ${{ vars.AWS_REGION || 'us-east-1' }}
        TF_VAR_backend_port: ${{ vars.BACKEND_PORT || '8900' }}
        TF_VAR_frontend_port: ${{ vars.FRONTEND_PORT || '3000' }}
        TF_VAR_vite_api_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_backend_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}
        TF_VAR_allowed_origins: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}
        TF_VAR_ngrok_port: ${{ vars.NGROK_PORT || '4040' }}
        TF_VAR_ngrok_url: ${{ vars.NGROK_URL || '' }}
        TF_VAR_ngrok_subdomain: ${{ vars.NGROK_SUBDOMAIN || '' }}
        TF_VAR_log_level: ${{ vars.LOG_LEVEL || 'INFO' }}
        TF_VAR_hot_lead_webhook_url: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}/api/alerts
        TF_VAR_hot_lead_email_recipients: ${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}
        TF_VAR_rate_limit_per_minute: ${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}
        TF_VAR_rate_limit_burst: ${{ vars.RATE_LIMIT_BURST || '200' }}
        TF_VAR_session_timeout_minutes: ${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}
        TF_VAR_remember_me_days: ${{ vars.REMEMBER_ME_DAYS || '30' }}
        TF_VAR_max_file_size_mb: ${{ vars.MAX_FILE_SIZE_MB || '10' }}
        TF_VAR_allowed_file_types: ${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}
        TF_VAR_carrental_frontend_domain: ''
        TF_VAR_carrental_api_domain: ''
        TF_VAR_subnet_id: ''
        TF_VAR_route53_zone_id: ''
        TF_VAR_alb_dns_name: ''
        TF_VAR_alb_zone_id: ''
      run: |
        echo "💥 Destroying SMS Seller Connect infrastructure in ${{ env.ENVIRONMENT }}..."
        
        terraform destroy -auto-approve
        
        echo "🗑️ Destruction completed!"

    - name: Display Destroy Results
      if: always()
      run: |
        echo "#### 💥 SMS Seller Connect Infrastructure Destruction Results"
        echo ""
        echo "**Status**: ${{ job.status == 'success' && '✅ Successfully Destroyed' || '❌ Destruction Failed' }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo "**Project**: ${{ env.PROJECT_NAME }}"
        echo ""
        echo "${{ job.status == 'success' && '⚠️ **All SMS Seller Connect infrastructure has been destroyed!**' || '❌ **Destruction failed - some resources may remain**' }}"
        echo ""
        echo "**Note**: State file preserved in S3 for audit purposes."

  verify-secrets:
    name: '🔐 Verify GitHub Secrets & Variables'
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'verify-secrets'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Verify Required Secrets
      run: |
        echo "🔐 Verifying GitHub Secrets and Variables..."
        echo ""
        
        # Track missing secrets/variables
        missing_secrets=()
        missing_vars=()
        
        # Required Secrets
        echo "### Required Secrets:"
        secrets=(
          "AWS_ACCESS_KEY_ID"
          "AWS_SECRET_ACCESS_KEY"
          "SSH_PUBLIC_KEY"
          "DB_HOST"
          "DB_USER"
          "DB_PASSWORD"
          "FLASK_SECRET_KEY"
          "JWT_SECRET_KEY"
          "TWILIO_ACCOUNT_SID"
          "TWILIO_AUTH_TOKEN"
          "TWILIO_PHONE_NUMBER"
          "OPENAI_API_KEY"
          "SENDGRID_API_KEY"
          "NGROK_AUTH_TOKEN"
          "HOT_LEAD_SMS_RECIPIENTS"
        )
        
        for secret in "${secrets[@]}"; do
          case "$secret" in
            "AWS_ACCESS_KEY_ID")
              if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.AWS_ACCESS_KEY_ID }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "AWS_SECRET_ACCESS_KEY")
              if [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.AWS_SECRET_ACCESS_KEY }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "SSH_PUBLIC_KEY")
              if [ -n "${{ secrets.SSH_PUBLIC_KEY }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.SSH_PUBLIC_KEY }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "DB_HOST")
              if [ -n "${{ secrets.DB_HOST }}" ]; then
                echo "✅ $secret - Set"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "DB_USER")
              if [ -n "${{ secrets.DB_USER }}" ]; then
                echo "✅ $secret - Set"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "DB_PASSWORD")
              if [ -n "${{ secrets.DB_PASSWORD }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.DB_PASSWORD }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "FLASK_SECRET_KEY")
              if [ -n "${{ secrets.FLASK_SECRET_KEY }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.FLASK_SECRET_KEY }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "JWT_SECRET_KEY")
              if [ -n "${{ secrets.JWT_SECRET_KEY }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.JWT_SECRET_KEY }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "TWILIO_ACCOUNT_SID")
              if [ -n "${{ secrets.TWILIO_ACCOUNT_SID }}" ]; then
                echo "✅ $secret - Set"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "TWILIO_AUTH_TOKEN")
              if [ -n "${{ secrets.TWILIO_AUTH_TOKEN }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.TWILIO_AUTH_TOKEN }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "TWILIO_PHONE_NUMBER")
              if [ -n "${{ secrets.TWILIO_PHONE_NUMBER }}" ]; then
                echo "✅ $secret - Set"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "OPENAI_API_KEY")
              if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.OPENAI_API_KEY }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "SENDGRID_API_KEY")
              if [ -n "${{ secrets.SENDGRID_API_KEY }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.SENDGRID_API_KEY }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "NGROK_AUTH_TOKEN")
              if [ -n "${{ secrets.NGROK_AUTH_TOKEN }}" ]; then
                echo "✅ $secret - Set (${#{{ secrets.NGROK_AUTH_TOKEN }}} chars)"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
            "HOT_LEAD_SMS_RECIPIENTS")
              if [ -n "${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}" ]; then
                echo "✅ $secret - Set"
              else
                echo "❌ $secret - Missing"
                missing_secrets+=("$secret")
              fi
              ;;
          esac
        done
        
        echo ""
        echo "### Required Variables:"
        variables=(
          "BACKEND_IMAGE"
          "FRONTEND_IMAGE"
          "SMS_FRONTEND_DOMAIN"
          "SMS_API_DOMAIN"
          "SENDGRID_FROM_EMAIL"
          "DB_PORT"
          "DB_NAME"
        )
        
        for var in "${variables[@]}"; do
          case "$var" in
            "BACKEND_IMAGE")
              if [ -n "${{ vars.BACKEND_IMAGE }}" ]; then
                echo "✅ $var - ${{ vars.BACKEND_IMAGE }}"
              else
                echo "⚠️ $var - Using fallback: 522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}"
              fi
              ;;
            "FRONTEND_IMAGE")
              if [ -n "${{ vars.FRONTEND_IMAGE }}" ]; then
                echo "✅ $var - ${{ vars.FRONTEND_IMAGE }}"
              else
                echo "⚠️ $var - Using fallback: 522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}"
              fi
              ;;
            "SMS_FRONTEND_DOMAIN")
              if [ -n "${{ vars.SMS_FRONTEND_DOMAIN }}" ]; then
                echo "✅ $var - ${{ vars.SMS_FRONTEND_DOMAIN }}"
              else
                echo "⚠️ $var - Using fallback: sms.typerelations.com"
              fi
              ;;
            "SMS_API_DOMAIN")
              if [ -n "${{ vars.SMS_API_DOMAIN }}" ]; then
                echo "✅ $var - ${{ vars.SMS_API_DOMAIN }}"
              else
                echo "⚠️ $var - Using fallback: api.sms.typerelations.com"
              fi
              ;;
            "SENDGRID_FROM_EMAIL")
              if [ -n "${{ vars.SENDGRID_FROM_EMAIL }}" ]; then
                echo "✅ $var - ${{ vars.SENDGRID_FROM_EMAIL }}"
              else
                echo "⚠️ $var - Using fallback: noreply@typerelations.com"
              fi
              ;;
            "DB_PORT")
              if [ -n "${{ vars.DB_PORT }}" ]; then
                echo "✅ $var - ${{ vars.DB_PORT }}"
              else
                echo "⚠️ $var - Using fallback: 5437"
              fi
              ;;
            "DB_NAME")
              if [ -n "${{ vars.DB_NAME }}" ]; then
                echo "✅ $var - ${{ vars.DB_NAME }}"
              else
                echo "⚠️ $var - Using fallback: sms_blast"
              fi
              ;;
          esac
        done
        
        echo ""
        echo "### Summary:"
        if [ ${#missing_secrets[@]} -eq 0 ] && [ ${#missing_vars[@]} -eq 0 ]; then
          echo "🎉 All required secrets and variables are configured!"
        else
          echo "❌ Missing configuration:"
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "Missing secrets: ${missing_secrets[*]}"
          fi
          if [ ${#missing_vars[@]} -gt 0 ]; then
            echo "Missing variables: ${missing_vars[*]}"
          fi
          exit 1
        fi

  redeploy:
    name: '🚀 Fast Redeploy Application'
    runs-on: ubuntu-latest
    needs: [format, validate, plan]
    if: |
      needs.plan.outputs.deployment-strategy == 'redeploy' && (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
        (github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.plan.outputs.has-changes == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan' && needs.plan.outputs.has-changes == 'true') ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'redeploy')
      )
    
    steps:
    - name: Fast Redeploy Strategy Notification
      run: |
        echo "🚀 FAST REDEPLOY STRATEGY ACTIVATED!"
        echo "====================================="
        echo ""
        echo "✨ Infrastructure already exists and is healthy"
        echo "🎯 Strategy: Update existing running infrastructure"
        echo "⚡ Estimated time: ~5 minutes (vs ~15 minutes for full deployment)"
        echo ""
        echo "🔄 What will be updated:"
        echo "  • Container images (backend & frontend)"
        echo "  • Environment configurations"
        echo "  • Application configurations"
        echo "  • Service restarts"
        echo ""
        echo "🏗️ What will NOT be changed:"
        echo "  • EC2 instance (already running)"
        echo "  • ALB configuration (already configured)"
        echo "  • Route53 DNS (already set)"
        echo "  • Security groups (already configured)"
        echo ""
        echo "🔧 Environment: ${{ env.ENVIRONMENT }}"
        echo "📦 Project: ${{ env.PROJECT_NAME }}"
        echo ""

    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Upload All Latest Scripts and Configuration to S3
      working-directory: ${{ env.TF_WORKING_DIR }}
      run: |
        echo "📤 Uploading ALL latest scripts and configuration to S3..."
        echo "This ensures the redeploy uses the newest versions from this commit"
        
        S3_BUCKET="sms-seller-connect-bucket"
        
        # Upload all scripts from the scripts directory
        echo "🔄 Uploading all scripts..."
        if [ -d "scripts" ]; then
          aws s3 sync scripts/ s3://${S3_BUCKET}/scripts/ --delete
          echo "✅ All scripts uploaded and old scripts removed"
        else
          echo "⚠️ Scripts directory not found"
        fi
        
        # Upload docker-compose configuration
        echo "🔄 Uploading Docker Compose configuration..."
        if [ -f "config/docker-compose.yml" ]; then
          aws s3 cp config/docker-compose.yml s3://${S3_BUCKET}/docker-compose/docker-compose.yml
          echo "✅ Docker Compose configuration uploaded"
        else
          echo "⚠️ Docker Compose configuration not found"
        fi
        
        # Upload environment template
        if [ -f "config/.env.template" ]; then
          aws s3 cp config/.env.template s3://${S3_BUCKET}/docker-compose/.env.template
          echo "✅ Environment template uploaded"
        else
          echo "ℹ️ Environment template not found (optional)"
        fi
        
        # Upload nginx configuration
        echo "🔄 Uploading Nginx configuration..."
        if [ -f "config/nginx.conf" ]; then
          aws s3 cp config/nginx.conf s3://${S3_BUCKET}/nginx/nginx.conf
          echo "✅ Nginx configuration uploaded"
        else
          echo "⚠️ Nginx configuration not found"
        fi
        
        echo ""
        echo "📋 S3 Upload Summary:"
        echo "=============================="
        echo "🔧 Scripts: s3://${S3_BUCKET}/scripts/"
        echo "🐳 Docker Compose: s3://${S3_BUCKET}/docker-compose/"
        echo "🌐 Nginx Config: s3://${S3_BUCKET}/nginx/"
        echo ""
        echo "✅ All latest files uploaded to S3 for redeploy"

    - name: Get EC2 Instance Details
      id: ec2-details
      run: |
        echo "🔍 Getting EC2 instance details..."
        
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-seller-connect-${{ env.ENVIRONMENT }}-ec2" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
          echo "❌ No running EC2 instance found for environment: ${{ env.ENVIRONMENT }}"
          exit 1
        fi
        
        INSTANCE_IP=$(aws ec2 describe-instances \
          --instance-ids "$INSTANCE_ID" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "✅ Found EC2 instance:"
        echo "Instance ID: $INSTANCE_ID"
        echo "Public IP: $INSTANCE_IP"
        
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: Execute Redeployment via SSM
      run: |
        echo "🚀 Executing redeployment on EC2 instance..."
        
        # Create the redeployment command with all environment variables
        COMMAND=$(cat << 'EOF'
        #!/bin/bash
        set -e
        
        # Export all environment variables for the redeployment script
        export AWS_REGION="${{ env.AWS_REGION }}"
        export S3_BUCKET="sms-seller-connect-bucket"
        export ENVIRONMENT="${{ env.ENVIRONMENT }}"
        
        # Docker Images
        export BACKEND_IMAGE="${{ vars.BACKEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend:${{ github.sha }}' }}"
        export FRONTEND_IMAGE="${{ vars.FRONTEND_IMAGE || '522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-frontend:${{ github.sha }}' }}"
        
        # Domain Configuration
        export SMS_API_DOMAIN="${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}"
        export SMS_FRONTEND_DOMAIN="${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}"
        
        # Database Configuration
        export DB_HOST="${{ secrets.DB_HOST }}"
        export DB_PORT="${{ vars.DB_PORT || '5437' }}"
        export DB_NAME="${{ vars.DB_NAME || 'sms_blast' }}"
        export DB_USER="${{ secrets.DB_USER }}"
        export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
        
        # Application Configuration
        export SECRET_KEY="${{ secrets.FLASK_SECRET_KEY }}"
        export JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
        export TWILIO_ACCOUNT_SID="${{ secrets.TWILIO_ACCOUNT_SID }}"
        export TWILIO_AUTH_TOKEN="${{ secrets.TWILIO_AUTH_TOKEN }}"
        export TWILIO_PHONE_NUMBER="${{ secrets.TWILIO_PHONE_NUMBER }}"
        export OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
        export OPENAI_MODEL="${{ vars.OPENAI_MODEL || 'gpt-4o' }}"
        export OPENAI_TEMPERATURE="${{ vars.OPENAI_TEMPERATURE || '0.3' }}"
        
        # SendGrid Configuration
        export SENDGRID_API_KEY="${{ secrets.SENDGRID_API_KEY }}"
        export SENDGRID_FROM_EMAIL="${{ vars.SENDGRID_FROM_EMAIL || 'noreply@typerelations.com' }}"
        
        # AWS Configuration
        export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
        export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        export S3_BUCKET_NAME="${{ vars.S3_BUCKET_NAME || 'grey-database-bucket' }}"
        
        # Hot Lead Configuration
        export HOT_LEAD_EMAIL_RECIPIENTS="${{ vars.HOT_LEAD_EMAIL_RECIPIENTS || 'dcaulcrick01@gmail.com' }}"
        export HOT_LEAD_SMS_RECIPIENTS="${{ secrets.HOT_LEAD_SMS_RECIPIENTS }}"
        
        # Rate Limiting
        export RATE_LIMIT_PER_MINUTE="${{ vars.RATE_LIMIT_PER_MINUTE || '100' }}"
        export RATE_LIMIT_BURST="${{ vars.RATE_LIMIT_BURST || '200' }}"
        
        # Session Configuration
        export SESSION_TIMEOUT_MINUTES="${{ vars.SESSION_TIMEOUT_MINUTES || '60' }}"
        export REMEMBER_ME_DAYS="${{ vars.REMEMBER_ME_DAYS || '30' }}"
        
        # File Upload Configuration
        export MAX_FILE_SIZE_MB="${{ vars.MAX_FILE_SIZE_MB || '10' }}"
        export ALLOWED_FILE_TYPES="${{ vars.ALLOWED_FILE_TYPES || 'csv,xlsx,txt' }}"
        
        # Download diagnostic and redeployment scripts
        echo "📥 Downloading diagnostic and redeployment scripts..."
        aws s3 cp s3://sms-seller-connect-bucket/scripts/debug-redeploy.sh /tmp/debug-redeploy.sh
        aws s3 cp s3://sms-seller-connect-bucket/scripts/redeploy-application.sh /tmp/redeploy-application.sh
        chmod +x /tmp/debug-redeploy.sh /tmp/redeploy-application.sh
        
        echo "🔍 Running pre-deployment diagnostics..."
        /tmp/debug-redeploy.sh || {
          echo "⚠️ Pre-deployment diagnostics completed with warnings"
        }
        
        echo ""
        echo "🚀 Executing redeployment..."
        if /tmp/redeploy-application.sh; then
          echo "✅ Redeployment completed successfully"
          
          echo ""
          echo "🔍 Running post-deployment verification..."
          /tmp/debug-redeploy.sh || echo "⚠️ Post-deployment diagnostics completed with warnings"
        else
          REDEPLOY_EXIT_CODE=\$?
          echo "❌ Redeployment failed with exit code \$REDEPLOY_EXIT_CODE"
          
          echo ""
          echo "🔍 Running failure diagnostics..."
          /tmp/debug-redeploy.sh || echo "⚠️ Failure diagnostics completed with warnings"
          
          echo ""
          echo "📋 Additional failure information:"
          echo "  - Exit code: \$REDEPLOY_EXIT_CODE"
          echo "  - Timestamp: \$(date)"
          echo "  - Instance: \$(curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null || echo 'unknown')"
          echo "  - Region: \$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.\$/' || echo 'unknown')"
          
          # Try to get recent system logs
          echo ""
          echo "📜 Recent system logs:"
          sudo journalctl --no-pager --lines=50 --since="10 minutes ago" || echo "Cannot access system logs"
          
          # Try to get Docker logs if available
          echo ""
          echo "🐳 Docker status:"
          sudo docker ps -a 2>/dev/null || echo "Cannot access Docker"
          
          if [ -d "/app/sms-seller-connect" ]; then
            echo ""
            echo "📦 Application status:"
            cd /app/sms-seller-connect
            sudo docker-compose ps 2>/dev/null || echo "Cannot access Docker Compose"
            sudo docker-compose logs --tail=50 2>/dev/null || echo "Cannot access Docker Compose logs"
          fi
          
          exit \$REDEPLOY_EXIT_CODE
        fi
        EOF
        )
        
        # Execute the command via SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ steps.ec2-details.outputs.instance_id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$COMMAND\"]" \
          --comment "SMS Seller Connect Application Redeployment" \
          --query 'Command.CommandId' \
          --output text)
        
        echo "📋 SSM Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        echo "⏳ Waiting for redeployment to complete..."
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2-details.outputs.instance_id }}"
        
        # Get command output
        echo "📊 Redeployment output:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2-details.outputs.instance_id }}" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check if command succeeded
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2-details.outputs.instance_id }}" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "🎉 Redeployment completed successfully!"
        else
          echo "❌ Redeployment failed with status: $STATUS"
          echo "Error output:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.ec2-details.outputs.instance_id }}" \
            --query 'StandardErrorContent' \
            --output text
          exit 1
        fi

    - name: Verify Application Health
      run: |
        echo "🔍 Verifying application health..."
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names "sms-seller-connect-${{ env.ENVIRONMENT }}-alb" \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        if [ "$ALB_DNS" != "None" ] && [ "$ALB_DNS" != "null" ]; then
          echo "🌐 Testing ALB health endpoint..."
          
          # Test ALB health endpoint with retries
          for i in {1..10}; do
            if curl -f -s "http://$ALB_DNS/alb-health" > /dev/null; then
              echo "✅ ALB health check passed"
              break
            else
              if [ $i -eq 10 ]; then
                echo "❌ ALB health check failed after 10 attempts"
              else
                echo "⏳ Attempt $i/10 failed, retrying in 30s..."
                sleep 30
              fi
            fi
          done
        fi
        
        echo "🎉 Application redeployment verification completed!"

    - name: Display Redeployment Results
      if: always()
      run: |
        echo "#### 🚀 SMS Seller Connect Application Redeployment Results"
        echo ""
        echo "**Status**: ${{ job.status == 'success' && '✅ Successfully Redeployed' || '❌ Redeployment Failed' }}"
        echo "**Environment**: ${{ env.ENVIRONMENT }}"
        echo "**Instance ID**: ${{ steps.ec2-details.outputs.instance_id }}"
        echo "**Instance IP**: ${{ steps.ec2-details.outputs.instance_ip }}"
        echo ""
        echo "**Frontend URL**: https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}"
        echo "**API URL**: https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}"
        echo ""
        echo "${{ job.status == 'success' && '🎉 **Application has been successfully redeployed without infrastructure changes!**' || '❌ **Redeployment failed - check logs for details**' }}"

  health-check:
    name: '🧪 Test Infrastructure & Application Health'
    runs-on: ubuntu-latest
    needs: [apply, redeploy]
    if: |
      always() && (
        (needs.apply.result == 'success') ||
        (needs.redeploy.result == 'success')
      )
    
    outputs:
      health-status: ${{ steps.overall-health.outputs.status }}
      backend-status: ${{ steps.backend-health.outputs.status }}
      frontend-status: ${{ steps.frontend-health.outputs.status }}
      container-status: ${{ steps.container-health.outputs.status }}
      ai-status: ${{ steps.ai-health.outputs.status }}
      sms-status: ${{ steps.sms-health.outputs.status }}
      scheduler-status: ${{ steps.scheduler-health.outputs.status }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Infrastructure Deployment Complete - Begin Stabilization
      run: |
        echo "🚀 Infrastructure deployment completed!"
        echo "======================================"
        echo "⏳ Beginning extended stabilization period..."
        echo ""
        echo "📋 What's happening during this wait:"
        echo "  1. EC2 instance completing boot process"
        echo "  2. User data scripts executing (Docker setup, service config)"
        echo "  3. Container images being pulled from ECR"
        echo "  4. Database connections being established"
        echo "  5. Backend API services initializing"
        echo "  6. AI processing services loading models"
        echo "  7. SMS/Twilio services connecting"
        echo "  8. Scheduler services starting"
        echo "  9. Frontend application building"
        echo "  10. All health checks becoming responsive"
        echo ""
        echo "⏰ EXTENDED STABILIZATION: 10 MINUTES"
        echo "This is intentionally long to ensure all complex services are fully operational."
        echo ""
        echo "Starting stabilization wait at $(date)..."
        sleep 600
        echo "✅ Extended stabilization period complete (10 minutes) - $(date)"

    - name: Get Infrastructure Details
      id: infra-details
      run: |
        echo "🔍 Gathering infrastructure details..."
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names "sms-seller-connect-${{ env.ENVIRONMENT }}-alb" \
          --query 'LoadBalancers[0].DNSName' \
          --output text 2>/dev/null || echo "not-found")
        
        # Get EC2 instance details
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=sms-seller-connect-${{ env.ENVIRONMENT }}-ec2" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text 2>/dev/null || echo "not-found")
        
        INSTANCE_IP=$(aws ec2 describe-instances \
          --instance-ids "$INSTANCE_ID" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text 2>/dev/null || echo "not-found")
        
        echo "📊 Infrastructure Details:"
        echo "ALB DNS: $ALB_DNS"
        echo "Instance ID: $INSTANCE_ID"
        echo "Instance IP: $INSTANCE_IP"
        
        echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
        
        # Set up base URLs for testing
        echo "frontend_url=https://${{ vars.SMS_FRONTEND_DOMAIN || 'sms.typerelations.com' }}" >> $GITHUB_OUTPUT
        echo "api_url=https://${{ vars.SMS_API_DOMAIN || 'api.sms.typerelations.com' }}" >> $GITHUB_OUTPUT
        echo "alb_url=http://$ALB_DNS" >> $GITHUB_OUTPUT

    - name: Final Service Readiness Check
      run: |
        echo "🔍 Final service readiness verification before comprehensive testing..."
        echo "⏳ Allowing additional 3 minutes for all services to reach fully stable state..."
        echo ""
        echo "🎯 This final wait ensures:"
        echo "  - All containers are not just running, but fully responsive"
        echo "  - Database connections are stable and performant"
        echo "  - API endpoints are responding consistently"
        echo "  - AI services have completed model loading"
        echo "  - Background services are operational"
        echo ""
        echo "Starting final readiness wait at $(date)..."
        sleep 180
        echo "✅ Final readiness verification complete (3 minutes) - $(date)"
        echo ""
        echo "🚀 TOTAL STABILIZATION TIME: 13 MINUTES"
        echo "Now beginning comprehensive infrastructure testing..."

    - name: Test Backend API Endpoints & Features
      id: backend-health
      run: |
        echo "🔧 Testing Backend API Endpoints & Features..."
        
        API_URL="${{ steps.infra-details.outputs.api_url }}"
        ALB_URL="${{ steps.infra-details.outputs.alb_url }}"
        SUCCESS_COUNT=0
        TOTAL_TESTS=0
        
        # Function to test endpoint
        test_endpoint() {
          local url="$1"
          local name="$2"
          local expected_status="${3:-200}"
          local method="${4:-GET}"
          local data="${5:-}"
          
          echo "Testing $name: $method $url"
          TOTAL_TESTS=$((TOTAL_TESTS + 1))
          
          if [ "$method" = "POST" ] && [ -n "$data" ]; then
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 -X POST -H "Content-Type: application/json" -d "$data" "$url")
          else
            response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 -X "$method" "$url")
          fi
          
          http_code=$(echo "$response" | grep "HTTPSTATUS:" | cut -d: -f2)
          body=$(echo "$response" | sed 's/HTTPSTATUS:.*//g')
          
          if [ "$http_code" -eq "$expected_status" ] || [ "$http_code" -eq 200 ]; then
            echo "✅ $name - HTTP $http_code"
            if [ -n "$body" ]; then
              echo "   Response: $(echo "$body" | head -c 200)..."
            fi
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "❌ $name - HTTP $http_code"
            if [ -n "$body" ]; then
              echo "   Error: $(echo "$body" | head -c 200)..."
            fi
          fi
          echo ""
        }
        
        echo "🏥 CORE HEALTH ENDPOINTS:"
        echo "========================"
        test_endpoint "$API_URL/health" "Primary Health Check"
        test_endpoint "$API_URL/api/health" "Extended Health Check"
        test_endpoint "$API_URL/" "API Root"
        
        echo "🔐 AUTHENTICATION SYSTEM:"
        echo "========================="
        test_endpoint "$API_URL/api/auth/login" "Login Endpoint" 405 "POST"
        test_endpoint "$API_URL/api/auth/register" "Registration Endpoint" 405 "POST"
        test_endpoint "$API_URL/api/auth/logout" "Logout Endpoint" 401 "POST"
        test_endpoint "$API_URL/api/auth/refresh" "Token Refresh" 401 "POST"
        
        echo "📱 SMS & COMMUNICATION:"
        echo "======================="
        test_endpoint "$API_URL/api/sms/send" "SMS Send Endpoint" 401 "POST"
        test_endpoint "$API_URL/api/sms/status" "SMS Status Check" 401
        test_endpoint "$API_URL/api/webhooks/sms" "SMS Webhook Endpoint" 405 "POST"
        test_endpoint "$API_URL/api/messages" "Messages Management" 401
        test_endpoint "$API_URL/api/messages/search" "Message Search" 401
        
        echo "👤 LEAD MANAGEMENT:"
        echo "=================="
        test_endpoint "$API_URL/api/leads" "Leads Endpoint" 401
        test_endpoint "$API_URL/api/leads/search" "Lead Search" 401
        test_endpoint "$API_URL/api/leads/import" "Lead Import" 401 "POST"
        test_endpoint "$API_URL/api/leads/export" "Lead Export" 401
        test_endpoint "$API_URL/api/leads/stats" "Lead Statistics" 401
        
        echo "🤖 AI PROCESSING:"
        echo "================="
        test_endpoint "$API_URL/api/ai/process" "AI Message Processing" 401 "POST"
        test_endpoint "$API_URL/api/ai/status" "AI Service Status" 401
        test_endpoint "$API_URL/api/ai/settings" "AI Configuration" 401
        
        echo "⏰ SCHEDULED MESSAGES:"
        echo "====================="
        test_endpoint "$API_URL/api/scheduler/status" "Scheduler Status" 401
        test_endpoint "$API_URL/api/scheduler/jobs" "Scheduled Jobs" 401
        test_endpoint "$API_URL/api/scheduler/create" "Create Schedule" 401 "POST"
        
        echo "📊 ANALYTICS & REPORTING:"
        echo "========================"
        test_endpoint "$API_URL/api/analytics" "Analytics Dashboard" 401
        test_endpoint "$API_URL/api/analytics/messages" "Message Analytics" 401
        test_endpoint "$API_URL/api/analytics/leads" "Lead Analytics" 401
        test_endpoint "$API_URL/api/analytics/performance" "Performance Metrics" 401
        test_endpoint "$API_URL/api/reports/generate" "Report Generation" 401 "POST"
        
        echo "📁 FILE MANAGEMENT:"
        echo "=================="
        test_endpoint "$API_URL/api/files/upload" "File Upload Endpoint" 401 "POST"
        test_endpoint "$API_URL/api/files/list" "File Listing" 401
        test_endpoint "$API_URL/api/files/download" "File Download" 401
        
        echo "⚙️ SYSTEM MANAGEMENT:"
        echo "===================="
        test_endpoint "$API_URL/api/system/status" "System Status" 401
        test_endpoint "$API_URL/api/system/logs" "System Logs" 401
        test_endpoint "$API_URL/api/system/config" "System Configuration" 401
        test_endpoint "$API_URL/api/alerts" "Alert System" 401
        
        echo "📚 DOCUMENTATION:"
        echo "================="
        test_endpoint "$API_URL/api/docs" "API Documentation"
        test_endpoint "$API_URL/api/openapi.json" "OpenAPI Schema"
        test_endpoint "$API_URL/redoc" "ReDoc Documentation"
        
        # Test via ALB as backup if many direct API calls failed
        if [ "$SUCCESS_COUNT" -lt 10 ]; then
          echo ""
          echo "🔄 BACKUP TESTING VIA ALB:"
          echo "========================="
          test_endpoint "$ALB_URL/health" "ALB Backend Health"
          test_endpoint "$ALB_URL/api/health" "ALB Backend API Health"
          test_endpoint "$ALB_URL/api/docs" "ALB API Documentation"
        fi
        
        echo ""
        echo "📊 BACKEND ENDPOINT SUMMARY:"
        echo "============================"
        echo "Total endpoints tested: $TOTAL_TESTS"
        echo "Successful responses: $SUCCESS_COUNT"
        echo "Success rate: $(( SUCCESS_COUNT * 100 / TOTAL_TESTS ))%"
        
        echo "backend_success_rate=$SUCCESS_COUNT/$TOTAL_TESTS" >> $GITHUB_OUTPUT
        
        # More lenient success criteria for comprehensive testing
        if [ "$SUCCESS_COUNT" -ge 10 ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ Backend comprehensive health check PASSED ($SUCCESS_COUNT/$TOTAL_TESTS endpoints responding)"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ Backend comprehensive health check FAILED ($SUCCESS_COUNT/$TOTAL_TESTS endpoints responding)"
        fi

    - name: Test AI Processing Services
      id: ai-health
      run: |
        echo "🤖 Testing AI Processing Services..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        if [ "$INSTANCE_ID" = "not-found" ]; then
          echo "❌ No EC2 instance found for AI testing"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Create AI service test script
        AI_TEST_SCRIPT='#!/bin/bash
        echo "🤖 AI PROCESSING SERVICE TEST"
        echo "============================"
        echo ""
        
        # Test AI service functionality within backend container
        echo "Testing AI service components..."
        
        if docker exec sms_backend python3 -c "
        import sys
        sys.path.append('\''/app'\'')
        
        try:
            # Test AI imports
            from src.ai.processor import AIProcessor
            from src.ai.message_analyzer import MessageAnalyzer
            print('\'✅ AI modules import successfully'\'')
            
            # Test AI configuration
            ai_processor = AIProcessor()
            print('\'✅ AI processor initialized'\'')
            
            # Test message analyzer
            analyzer = MessageAnalyzer()
            print('\'✅ Message analyzer initialized'\'')
            
            # Test basic AI functionality (without API calls)
            test_message = '\''Hello, I am interested in your property'\''
            result = analyzer.analyze_sentiment(test_message)
            print(f'\'✅ AI sentiment analysis working: {result}'\'')
            
        except Exception as e:
            print(f'\'❌ AI service test failed: {e}'\'')
            import traceback
            traceback.print_exc()
            exit(1)
        " 2>&1; then
          echo "✅ AI processing services are functional"
        else
          echo "❌ AI processing services failed"
          echo "Checking AI-related logs..."
          docker logs --tail 20 sms_backend | grep -i -E "(ai|openai|gpt|nlp)" || echo "No AI-related logs found"
        fi
        
        echo ""
        echo "🔍 AI Configuration Check:"
        docker exec sms_backend env | grep -E "^(OPENAI_|AI_|GPT_)" | sed "s/=.*/=***HIDDEN***/" || echo "No AI environment variables found"'
        
        # Execute AI test via SSM
        echo "🚀 Executing AI functionality test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$AI_TEST_SCRIPT\"]" \
          --comment "AI Processing Service Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 20
        
        # Get and display results
        echo "📊 AI Service Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ AI processing services test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ AI processing services test failed"
        fi

    - name: Test SMS & Twilio Services  
      id: sms-health
      run: |
        echo "📱 Testing SMS & Twilio Services..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        # Create SMS service test script
        SMS_TEST_SCRIPT='#!/bin/bash
        echo "📱 SMS & TWILIO SERVICE TEST"
        echo "==========================="
        echo ""
        
        # Test SMS service functionality within backend container
        echo "Testing SMS service components..."
        
        if docker exec sms_backend python3 -c "
        import sys
        sys.path.append('\''/app'\'')
        
        try:
            # Test SMS imports
            from src.sms.twilio_client import TwilioClient
            from src.sms.message_handler import MessageHandler
            print('\'✅ SMS modules import successfully'\'')
            
            # Test SMS configuration
            twilio_client = TwilioClient()
            print('\'✅ Twilio client initialized'\'')
            
            # Test message handler
            handler = MessageHandler()
            print('\'✅ Message handler initialized'\'')
            
            # Test Twilio credentials (without sending)
            if hasattr(twilio_client, '\''client'\'') and twilio_client.client:
                print('\'✅ Twilio credentials configured'\'')
            else:
                print('\'⚠️ Twilio credentials may not be configured'\'')
                
        except Exception as e:
            print(f'\'❌ SMS service test failed: {e}'\'')
            import traceback
            traceback.print_exc()
            exit(1)
        " 2>&1; then
          echo "✅ SMS services are functional"
        else
          echo "❌ SMS services failed"
          echo "Checking SMS-related logs..."
          docker logs --tail 20 sms_backend | grep -i -E "(sms|twilio|message)" || echo "No SMS-related logs found"
        fi
        
        echo ""
        echo "🔍 SMS Configuration Check:"
        docker exec sms_backend env | grep -E "^(TWILIO_|SMS_)" | sed "s/=.*/=***HIDDEN***/" || echo "No SMS environment variables found"'
        
        # Execute SMS test via SSM
        echo "🚀 Executing SMS functionality test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$SMS_TEST_SCRIPT\"]" \
          --comment "SMS & Twilio Service Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 20
        
        # Get and display results
        echo "📊 SMS Service Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ SMS & Twilio services test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ SMS & Twilio services test failed"
        fi

    - name: Test Scheduled Message Services
      id: scheduler-health
      run: |
        echo "⏰ Testing Scheduled Message Services..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        # Create scheduler service test script
        SCHEDULER_TEST_SCRIPT='#!/bin/bash
        echo "⏰ SCHEDULED MESSAGE SERVICE TEST"
        echo "================================"
        echo ""
        
        # Test scheduler service functionality
        echo "Testing scheduler service components..."
        
        if docker exec sms_backend python3 -c "
        import sys
        sys.path.append('\''/app'\'')
        
        try:
            # Test scheduler imports
            from src.scheduler.message_scheduler import MessageScheduler
            from src.scheduler.job_manager import JobManager
            print('\'✅ Scheduler modules import successfully'\'')
            
            # Test scheduler initialization
            scheduler = MessageScheduler()
            print('\'✅ Message scheduler initialized'\'')
            
            # Test job manager
            job_manager = JobManager()
            print('\'✅ Job manager initialized'\'')
            
            # Test scheduler status
            if scheduler.is_running():
                print('\'✅ Scheduler is running'\'')
            else:
                print('\'⚠️ Scheduler is not currently running'\'')
                
        except Exception as e:
            print(f'\'❌ Scheduler service test failed: {e}'\'')
            import traceback
            traceback.print_exc()
            exit(1)
        " 2>&1; then
          echo "✅ Scheduler services are functional"
        else
          echo "❌ Scheduler services failed"
          echo "Checking scheduler-related logs..."
          docker logs --tail 20 sms_backend | grep -i -E "(scheduler|cron|job|task)" || echo "No scheduler-related logs found"
        fi
        
        echo ""
        echo "🔍 Background Services Check:"
        echo "Checking if scheduled message processes are running..."
        ps aux | grep -E "(send_scheduled_messages|process_inbound)" || echo "No background message processes found"'
        
        # Execute scheduler test via SSM
        echo "🚀 Executing scheduler functionality test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$SCHEDULER_TEST_SCRIPT\"]" \
          --comment "Scheduler Service Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 20
        
        # Get and display results
        echo "📊 Scheduler Service Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ Scheduled message services test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ Scheduled message services test failed"
        fi

    - name: Test Frontend Application
      id: frontend-health
      run: |
        echo "🎨 Testing Frontend Application..."
        
        FRONTEND_URL="${{ steps.infra-details.outputs.frontend_url }}"
        ALB_URL="${{ steps.infra-details.outputs.alb_url }}"
        SUCCESS_COUNT=0
        TOTAL_TESTS=0
        
        # Function to test frontend endpoint
        test_frontend() {
          local url="$1"
          local name="$2"
          
          echo "Testing $name: $url"
          TOTAL_TESTS=$((TOTAL_TESTS + 1))
          
          response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 "$url")
          http_code=$(echo "$response" | grep "HTTPSTATUS:" | cut -d: -f2)
          body=$(echo "$response" | sed 's/HTTPSTATUS:.*//g')
          
          if [ "$http_code" -eq 200 ]; then
            # Check if response contains expected frontend content
            if echo "$body" | grep -q -i -E "(html|react|vue|angular|app|title)" || echo "$body" | grep -q "<!DOCTYPE"; then
              echo "✅ $name - HTTP $http_code (Valid HTML/App content)"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              echo "⚠️ $name - HTTP $http_code (Unexpected content)"
              echo "   Content preview: $(echo "$body" | head -c 100)..."
            fi
          else
            echo "❌ $name - HTTP $http_code"
            if [ -n "$body" ]; then
              echo "   Error: $(echo "$body" | head -c 100)..."
            fi
          fi
          echo ""
        }
        
        # Test frontend endpoints
        test_frontend "$FRONTEND_URL" "Frontend Root"
        test_frontend "$FRONTEND_URL/login" "Login Page"
        test_frontend "$FRONTEND_URL/dashboard" "Dashboard Page"
        
        # Test static assets (if available)
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if curl -s --max-time 10 "$FRONTEND_URL" | grep -q -i -E "(css|js|script|link)" ; then
          echo "✅ Frontend static assets detected"
          SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
          echo "⚠️ Frontend static assets not clearly detected"
        fi
        
        echo "frontend_success_rate=$SUCCESS_COUNT/$TOTAL_TESTS" >> $GITHUB_OUTPUT
        
        if [ "$SUCCESS_COUNT" -ge 2 ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ Frontend health check passed ($SUCCESS_COUNT/$TOTAL_TESTS checks passed)"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ Frontend health check failed ($SUCCESS_COUNT/$TOTAL_TESTS checks passed)"
        fi

    - name: Test Database Connectivity
      id: database-health
      run: |
        echo "🗄️ Testing Database Connectivity..."
        
        INSTANCE_ID="${{ steps.infra-details.outputs.instance_id }}"
        
        if [ "$INSTANCE_ID" = "not-found" ]; then
          echo "❌ No EC2 instance found for database test"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Create database connectivity test script
        DB_TEST_SCRIPT='#!/bin/bash
        echo "🗄️ DATABASE CONNECTIVITY TEST"
        echo "============================="
        echo ""
        
        # Test database connectivity via backend container
        echo "Testing database connectivity via backend..."
        
        # Check if backend container can connect to database
        if docker exec sms_backend python3 -c "
        import psycopg2
        import os
        try:
            conn = psycopg2.connect(
                host=os.environ['\''DB_HOST'\''],
                port=os.environ['\''DB_PORT'\''],
                database=os.environ['\''DB_NAME'\''],
                user=os.environ['\''DB_USER'\''],
                password=os.environ['\''DB_PASSWORD'\'']
            )
            cursor = conn.cursor()
            cursor.execute('\''SELECT version();'\'')
            version = cursor.fetchone()
            print('\''✅ Database connection successful'\'')
            print(f'\''   PostgreSQL version: {version[0][:50]}...'\'')
            
            # Test basic queries
            cursor.execute('\''SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = %s;'\'', ('\''public'\'',))
            table_count = cursor.fetchone()[0]
            print(f'\''   Tables in public schema: {table_count}'\'')
            
            cursor.close()
            conn.close()
        except Exception as e:
            print(f'\''❌ Database connection failed: {e}'\'')
            exit(1)
        " 2>&1; then
          echo "✅ Database connectivity test passed"
        else
          echo "❌ Database connectivity test failed"
          echo "Checking container logs for database errors..."
          docker logs --tail 10 sms_backend | grep -i -E "(database|db|postgres|connection)" || echo "No database-related logs found"
        fi
        
        echo ""
        echo "🔍 Backend database configuration:"
        docker exec sms_backend env | grep -E "^(DB_|DATABASE_)" | sed "s/PASSWORD=.*/PASSWORD=***HIDDEN***/" || echo "Could not retrieve DB config"'
        
        # Execute database test via SSM
        echo "🚀 Executing database connectivity test..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"$DB_TEST_SCRIPT\"]" \
          --comment "Database Connectivity Test" \
          --query 'Command.CommandId' \
          --output text)
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --max-attempts 15
        
        # Get and display results
        echo "📊 Database Test Results:"
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text
        
        # Check command status
        STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'Status' \
          --output text)
        
        if [ "$STATUS" = "Success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ Database connectivity test completed successfully"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ Database connectivity test failed"
        fi

    - name: Checkout
      uses: actions/checkout@v4

    - name: Validate GitHub Secrets and Variables
      id: validate-config
      run: |
        echo "🔐 Validating GitHub Secrets and Variables Configuration..."
        echo "========================================================"
        echo ""
        
        VALIDATION_ERRORS=0
        VALIDATION_WARNINGS=0
        
        # Function to check required secret
        check_secret() {
          local secret_name="$1"
          local secret_value="$2"
          local is_required="${3:-true}"
          
          if [ -z "$secret_value" ] || [ "$secret_value" = "" ]; then
            if [ "$is_required" = "true" ]; then
              echo "❌ MISSING REQUIRED SECRET: $secret_name"
              VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            else
              echo "⚠️ MISSING OPTIONAL SECRET: $secret_name"
              VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
            fi
          else
            # Check if secret looks valid (basic format validation)
            case "$secret_name" in
              *_KEY|*_TOKEN|*_SECRET*) 
                if [ ${#secret_value} -lt 10 ]; then
                  echo "⚠️ SECRET TOO SHORT: $secret_name (${#secret_value} characters)"
                  VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                else
                  echo "✅ SECRET VALID: $secret_name (${#secret_value} characters)"
                fi
                ;;
              *_HOST|*_URL|*_DOMAIN*)
                if echo "$secret_value" | grep -q -E "^[a-zA-Z0-9.-]+$|^https?://"; then
                  echo "✅ SECRET VALID: $secret_name"
                else
                  echo "⚠️ SECRET FORMAT WARNING: $secret_name (may be invalid format)"
                  VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                fi
                ;;
              *)
                echo "✅ SECRET VALID: $secret_name (configured)"
                ;;
            esac
          fi
        }
        
        # Function to check required variable
        check_variable() {
          local var_name="$1"
          local var_value="$2"
          local is_required="${3:-true}"
          local default_value="${4:-}"
          
          if [ -z "$var_value" ] || [ "$var_value" = "" ]; then
            if [ -n "$default_value" ]; then
              echo "✅ VARIABLE USING DEFAULT: $var_name (default: $default_value)"
            elif [ "$is_required" = "true" ]; then
              echo "❌ MISSING REQUIRED VARIABLE: $var_name"
              VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            else
              echo "⚠️ MISSING OPTIONAL VARIABLE: $var_name"
              VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
            fi
          else
            echo "✅ VARIABLE VALID: $var_name ($var_value)"
          fi
        }
        
        echo "🔑 REQUIRED SECRETS VALIDATION:"
        echo "==============================="
        check_secret "AWS_ACCESS_KEY_ID" "${{ secrets.AWS_ACCESS_KEY_ID }}"
        check_secret "AWS_SECRET_ACCESS_KEY" "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        check_secret "SSH_PUBLIC_KEY" "${{ secrets.SSH_PUBLIC_KEY }}"
        check_secret "JWT_SECRET_KEY" "${{ secrets.JWT_SECRET_KEY }}"
        check_secret "DB_HOST" "${{ secrets.DB_HOST }}"
        check_secret "DB_USER" "${{ secrets.DB_USER }}"
        check_secret "DB_PASSWORD" "${{ secrets.DB_PASSWORD }}"
        
        echo ""
        echo "📱 SMS/COMMUNICATION SECRETS:"
        echo "============================="
        check_secret "TWILIO_ACCOUNT_SID" "${{ secrets.TWILIO_ACCOUNT_SID }}"
        check_secret "TWILIO_AUTH_TOKEN" "${{ secrets.TWILIO_AUTH_TOKEN }}"
        check_secret "TWILIO_PHONE_NUMBER" "${{ secrets.TWILIO_PHONE_NUMBER }}"
        
        echo ""
        echo "🤖 AI/EMAIL SECRETS:"
        echo "==================="
        check_secret "OPENAI_API_KEY" "${{ secrets.OPENAI_API_KEY }}"
        check_secret "SENDGRID_API_KEY" "${{ secrets.SENDGRID_API_KEY }}" false
        check_secret "NGROK_AUTH_TOKEN" "${{ secrets.NGROK_AUTH_TOKEN }}" false
        
        echo ""
        echo "🌐 REQUIRED VARIABLES:"
        echo "====================="
        check_variable "AWS_REGION" "${{ vars.AWS_REGION }}" true "us-east-1"
        check_variable "PROJECT_NAME" "${{ vars.PROJECT_NAME }}" true "sms-seller-connect"
        check_variable "SMS_FRONTEND_DOMAIN" "${{ vars.SMS_FRONTEND_DOMAIN }}" true "sms.typerelations.com"
        check_variable "SMS_API_DOMAIN" "${{ vars.SMS_API_DOMAIN }}" true "api.sms.typerelations.com"
        check_variable "DOMAIN_ZONE_NAME" "${{ vars.DOMAIN_ZONE_NAME }}" true "typerelations.com"
        
        echo ""
        echo "🔧 INFRASTRUCTURE VARIABLES:"
        echo "============================"
        check_variable "INSTANCE_TYPE" "${{ vars.INSTANCE_TYPE }}" false "t2.micro"
        check_variable "AMI_ID" "${{ vars.AMI_ID }}" false "ami-0c02fb55956c7d316"
        check_variable "KEY_NAME" "${{ vars.KEY_NAME }}" false "sms-seller-connect-key"
        check_variable "VPC_NAME" "${{ vars.VPC_NAME }}" false "Grey-VPC"
        check_variable "S3_BUCKET_NAME" "${{ vars.S3_BUCKET_NAME }}" false "sms-seller-connect-bucket"
        
        echo ""
        echo "🐳 CONTAINER VARIABLES:"
        echo "======================"
        check_variable "ECR_REPO_URL" "${{ vars.ECR_REPO_URL }}" false "522814698925.dkr.ecr.us-east-1.amazonaws.com/sms-wholesaling-backend"
        check_variable "BACKEND_IMAGE" "${{ vars.BACKEND_IMAGE }}" false
        check_variable "FRONTEND_IMAGE" "${{ vars.FRONTEND_IMAGE }}" false
        check_variable "CONTAINER_TAG" "${{ vars.CONTAINER_TAG }}" false "latest"
        
        echo ""
        echo "📊 VALIDATION SUMMARY:"
        echo "====================="
        echo "Validation Errors: $VALIDATION_ERRORS"
        echo "Validation Warnings: $VALIDATION_WARNINGS"
        
        # Set outputs for later steps
        echo "validation_errors=$VALIDATION_ERRORS" >> $GITHUB_OUTPUT
        echo "validation_warnings=$VALIDATION_WARNINGS" >> $GITHUB_OUTPUT
        
        if [ $VALIDATION_ERRORS -gt 0 ]; then
          echo ""
          echo "❌ VALIDATION FAILED: $VALIDATION_ERRORS critical configuration issues found"
          echo ""
          echo "🔧 REQUIRED ACTIONS:"
          echo "==================="
          echo "1. Go to your GitHub repository settings"
          echo "2. Navigate to 'Secrets and variables' → 'Actions'"
          echo "3. Add missing secrets to 'Repository secrets'"
          echo "4. Add missing variables to 'Repository variables'"
          echo ""
          echo "❌ Deployment cannot proceed until all required configuration is set!"
          exit 1
        elif [ $VALIDATION_WARNINGS -gt 0 ]; then
          echo ""
          echo "⚠️ VALIDATION PASSED WITH WARNINGS: $VALIDATION_WARNINGS non-critical issues found"
          echo "Deployment will proceed using defaults where applicable."
        else
          echo ""
          echo "✅ VALIDATION PASSED: All required configuration is properly set"
        fi

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
